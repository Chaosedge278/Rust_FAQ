<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Rust FAQ by Songbird0</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/Songbird0/Rust_FAQ">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/Songbird0/Rust_FAQ/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/Songbird0/Rust_FAQ/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Rust FAQ</h1>
          <p>FAQ Rust construite sur [et avec les outils de] developpez.com.</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/Songbird0">Songbird0</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <h1>
<a id="langage" class="anchor" href="#langage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Langage</h1>

<h2>
<a id="questions-générales" class="anchor" href="#questions-g%C3%A9n%C3%A9rales" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Questions générales</h2>

<h3>
<a id="comment-déclarer-une-variable-" class="anchor" href="#comment-d%C3%A9clarer-une-variable-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment déclarer une variable ?</h3>

<p>La déclaration d'une variable en Rust se fait par le biais du mot-clé <code>let</code>, permettant ainsi de différencier une assignation d'une expression.</p>

<p>Vous pouvez bien entendu déclarer et initialiser plusieurs variables en même temps de cette manière :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> (foo<span class="pl-k">,</span> bar<span class="pl-k">,</span> baz) <span class="pl-k">=</span> (<span class="pl-c1">117</span><span class="pl-k">,</span> <span class="pl-c1">42</span><span class="pl-k">,</span> <span class="pl-s">"Hello world!"</span>)<span class="pl-k">;</span>
}</pre></div>

<p>Ou effectuer une déclaration multiligne :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo <span class="pl-k">=</span> <span class="pl-c1">117</span><span class="pl-k">;</span>
    <span class="pl-k">let</span> bar <span class="pl-k">=</span> <span class="pl-c1">42</span><span class="pl-k">;</span>
    <span class="pl-k">let</span> baz <span class="pl-k">=</span> <span class="pl-s">"Hello world!"</span><span class="pl-k">;</span>
}</pre></div>

<p>Voir aussi : <a href="#rust-poss%C3%A8de-t-il-un-typage-dynamique">Rust possède-t-il un typage dynamique ?</a></p>

<h3>
<a id="comment-assigner-un-objet-par-référence-" class="anchor" href="#comment-assigner-un-objet-par-r%C3%A9f%C3%A9rence-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment assigner un objet par référence ?</h3>

<p>Il existe deux façons de faire :</p>

<ol>
<li>Préciser par le biais du caractère &amp;. (C-style)</li>
<li>En utilisant le mot-clé <code>ref</code> comme ceci :</li>
</ol>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo <span class="pl-k">=</span> <span class="pl-c1">117i32</span><span class="pl-k">;</span>
    <span class="pl-k">let</span> <span class="pl-k">ref</span> bar <span class="pl-k">=</span> foo<span class="pl-k">;</span>
    <span class="pl-k">let</span> baz <span class="pl-k">=</span> <span class="pl-k">&amp;</span>foo<span class="pl-k">;</span> <span class="pl-c">//idem</span>
}</pre></div>

<h3>
<a id="rust-possède-t-il-un-typage-dynamique-" class="anchor" href="#rust-poss%C3%A8de-t-il-un-typage-dynamique-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Rust possède-t-il un typage dynamique ?</h3>

<p>Non.</p>

<p>Bien qu'il en donne l'air grâce à une syntaxe très aérée, Rust dispose d'un typage statique mais « optionnel » pour le développeur si il désire faire abstraction des types, mais il perdra, en toute logique, l'avantage de choisir la quantité de mémoire que sa ressource consommera.</p>

<p>Vous ne pouvez, par exemple, pas faire ceci :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> <span class="pl-k">mut</span> foo <span class="pl-k">=</span> <span class="pl-c1">1</span><span class="pl-k">;</span>
    foo <span class="pl-k">=</span> <span class="pl-s">" Hello world !"</span><span class="pl-k">;</span>
}</pre></div>

<p>Le type ayant été fixé par la première donnée, il n'est plus possible de changer en cours de route.</p>

<p>Voir aussi : <a href="#comment-typer-ses-donn%C3%A9esvariables">Comment typer ses données/variables</a> ?</p>

<h3>
<a id="comment-typer-ses-donnéesvariables-" class="anchor" href="#comment-typer-ses-donn%C3%A9esvariables-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment typer ses données/variables ?</h3>

<p>Pour les types primitifs, il existe deux manières de typer une variable :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">i32</span> <span class="pl-k">=</span> <span class="pl-c1">117</span><span class="pl-k">;</span>
}</pre></div>

<p>Ou :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> bar <span class="pl-k">=</span> <span class="pl-c1">117i32</span><span class="pl-k">;</span>
}</pre></div>

<h3>
<a id="quelle-est-la-différence-entre-str-et-string-" class="anchor" href="#quelle-est-la-diff%C3%A9rence-entre-str-et-string-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quelle est la différence entre &amp;str et String ?</h3>

<p><code>&amp;str</code> est un type non mutable représentant une chaîne de caractères tandis que <code>String</code> est un wrapper mutable au-dessus de ce dernier.</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">str</span> <span class="pl-k">=</span> <span class="pl-s">"Hello world!"</span><span class="pl-k">;</span> <span class="pl-c">// ça fonctionne</span>
    <span class="pl-k">let</span> bar<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> foo<span class="pl-k">;</span> <span class="pl-c">// erreur</span>
    <span class="pl-k">let</span> baz<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> foo<span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">;</span> <span class="pl-c">// Ok !</span>
    <span class="pl-k">let</span> baz<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> foo<span class="pl-k">.</span><span class="pl-c1">to_owned</span>()<span class="pl-k">;</span> <span class="pl-c">// Ok ! (équivalent avec la ligne du dessus)</span>
}</pre></div>

<h3>
<a id="comment-créer-une-chaîne-de-caractères-" class="anchor" href="#comment-cr%C3%A9er-une-cha%C3%AEne-de-caract%C3%A8res-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment créer une chaîne de caractères ?</h3>

<p>La question pourrait paraître évidente dans d'autres langages, toutefois, après avoir écrit quelque chose de ce style :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-s">"Hello world!"</span><span class="pl-k">;</span>
}</pre></div>

<p>Le compilateur vous a renvoyé cette erreur :</p>

<pre lang="texinfo"><code>  |&gt;
4 |&gt;    let foo: String = "Hello world!";
  |&gt;                      ^^^^^^^^^^^^^^ expected struct `std::string::String`, found &amp;-ptr
</code></pre>

<p>Il se trouve que la structure <code>String</code> est un wrapper.</p>

<p>Vous vous retrouvez donc à typer votre variable pour accueillir une instance de la structure <code>String</code> alors que vous créez une chaîne de caractères primitive.</p>

<p>Pour remédier au problème (si vous souhaitez malgré tout utiliser le wrapper), vous pouvez convertir une chaîne de caractères de type <code>&amp;str</code> grâce à la fonction <code>String::from()</code> :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-c1">from</span>(<span class="pl-s">"Hello world!"</span>)<span class="pl-k">;</span>
    <span class="pl-c">// ou</span>
    <span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">str</span> <span class="pl-k">=</span> <span class="pl-s">"Hello world!"</span><span class="pl-k">;</span>
}</pre></div>

<p>Ou encore avec les méthodes <code>to_owned</code> et <code>to_string</code> (à préférer à la méthode <code>from</code> qui est un peu plus générale) :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo <span class="pl-k">=</span> <span class="pl-s">"Hello world!"</span><span class="pl-k">.</span><span class="pl-c1">to_owned</span>()<span class="pl-k">;</span>
    <span class="pl-k">let</span> foo <span class="pl-k">=</span> <span class="pl-s">"Hello world!"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">;</span>
}</pre></div>

<h3>
<a id="quelle-version-de-rust-est-recommandée-" class="anchor" href="#quelle-version-de-rust-est-recommand%C3%A9e-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quelle version de Rust est recommandée ?</h3>

<p>Actuellement<strong><em>2 novembre 2016</em></strong>, la version stable la plus récente est la <strong>1.12.1</strong>.</p>

<p>Mais vous pouvez toutefois utiliser une version un peu plus vieille.</p>

<p>Pour cette Q/R, la version de Rust sur mon poste était la <strong>1.9.0</strong>.</p>

<p>Voir aussi : <a href="https://www.rust-lang.org/en-US/" title="Ouvrir un nouvel onglet">Page officielle du langage Rust</a></p>

<h3>
<a id="rust-est-il-orienté-objet-" class="anchor" href="#rust-est-il-orient%C3%A9-objet-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Rust est-il orienté objet ?</h3>

<p>Rust hérite des structures du <em>C</em>, elles n'incluent donc pas l'encapsulation des données comme nous pourrions l'imaginer avec une classe.</p>

<p>Il dispose d'un aspect de la POO, de prime abord, assez primitif ; Rust permet toutefois de bénéficier du polymorphisme grâce aux « traits » qui pourraient être comparées aux interfaces Java/C#.</p>

<p>Cependant, le langage ne supporte pas l'héritage multiple (ni l'héritage simple) entre les structures : comme il serait possible de le faire avec des classes, bien qu'il soit possible de le faire avec des traits.</p>

<p>Par conséquent, Rust est donc orienté objet puisqu'il possède plusieurs parties de ce paradigme mais n'est pas un langage <em>pur</em> objet.</p>

<p>Voir aussi : <a href="#quest-ce-quun-trait">Qu'est-ce qu'un « trait » ?</a></p>

<h3>
<a id="quest-ce-quun--trait--" class="anchor" href="#quest-ce-quun--trait--" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Qu'est-ce qu'un « trait » ?</h3>

<p>Un trait pourrait être comparé aux interfaces que l'on peut retrouver dans la plupart des langages orientés objet. (e.g. Java, C#).</p>

<p>Les traits vous permettent de déclarer des fonctions abstraites/virtuelles pour ensuite les implémenter au sein d'une structure grâce au mot-clé <code>impl</code> comme ceci :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">trait</span> <span class="pl-k">Greeter</span> {
    <span class="pl-k">fn</span> <span class="pl-en">greetings</span>(<span class="pl-k">&amp;</span><span class="pl-v">self</span>)<span class="pl-k">;</span>
}

<span class="pl-k">struct</span> <span class="pl-k">Person</span><span class="pl-k">;</span>

<span class="pl-k">impl</span> <span class="pl-k">Greeter</span> <span class="pl-k">for</span> <span class="pl-k">Person</span> {
    <span class="pl-k">fn</span> <span class="pl-en">greetings</span>(<span class="pl-k">&amp;</span><span class="pl-v">self</span>) {
        println<span class="pl-k">!</span>(<span class="pl-s">"Hello, my friends!"</span>)<span class="pl-k">;</span>
    }
}

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> person <span class="pl-k">=</span> <span class="pl-k">Person</span><span class="pl-k">;</span>
    person<span class="pl-k">.</span><span class="pl-c1">greetings</span>()<span class="pl-k">;</span>
}</pre></div>

<p>Pour aller au plus simple, un trait vous permet d'écrire un ensemble de fonctions qu'un objet est obligé d'implémenter lorsqu'il hérite de ce trait.</p>

<h3>
<a id="rust-supporte-t-il-la-surchage-des-fonctions-" class="anchor" href="#rust-supporte-t-il-la-surchage-des-fonctions-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Rust supporte-t-il la surchage des fonctions ?</h3>

<p>Rust ne supporte pas la surcharge des fonctions.</p>

<p>Le langage repose sur le « Builder Pattern » qui consiste à concevoir des « fabriques/factories » chargées de générer l'objet désiré.</p>

<p>Vous pouvez retrouver quelques explications à propos de ce design pattern <a href="https://doc.rust-lang.org/book/method-syntax.html#builder-pattern">ici</a> ou encore <a href="https://fr.wikipedia.org/wiki/Monteur_(patron_de_conception)#Exemple" title="Ouvrir un nouvel onglet">ici</a>.</p>

<p>Voir aussi : <a href="#comment-d%C3%A9clarer-des-param%C3%A8tres-optionnels">Comment déclarer des paramètres optionnels</a> ?</p>

<h3>
<a id="comment-déclarer-des-paramètres-optionnels-" class="anchor" href="#comment-d%C3%A9clarer-des-param%C3%A8tres-optionnels-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment déclarer des paramètres optionnels ?</h3>

<p>Il n'est pas possible de déclarer des paramètres optionnels avec Rust dans sa version actuelle.</p>

<p>Toutefois, il est toujours possible d'user de macros pour capturer différentes expressions et ainsi adapter votre code en fonction de la situation.</p>

<p>Le langage repose sur le « Builder Pattern » qui consiste à concevoir des « fabriques/factories » chargées de générer l'objet désiré.</p>

<p>Vous pouvez retrouver quelques explications à propos de ce design pattern <a href="https://doc.rust-lang.org/book/method-syntax.html#builder-pattern">ici</a> ou encore <a href="https://fr.wikipedia.org/wiki/Monteur_(patron_de_conception)" title="Ouvrir un nouvel onglet">ici</a>.</p>

<p>Voir aussi : <a href="#comment-utiliser-une-macro">Comment utiliser une macro ?</a></p>

<h3>
<a id="comment-créer-un-tableau-" class="anchor" href="#comment-cr%C3%A9er-un-tableau-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment créer un tableau ?</h3>

<p>Un tableau dans sa forme la plus primitive se déclare comme ceci :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">let</span> foo<span class="pl-k">:</span> [<span class="pl-k">i32</span><span class="pl-k">;</span> <span class="pl-c1">10</span>] <span class="pl-k">=</span> [<span class="pl-c1">0</span><span class="pl-k">,</span> <span class="pl-c1">1</span><span class="pl-k">,</span> <span class="pl-c1">2</span><span class="pl-k">,</span> <span class="pl-c1">3</span><span class="pl-k">,</span> <span class="pl-c1">4</span><span class="pl-k">,</span> <span class="pl-c1">5</span><span class="pl-k">,</span> <span class="pl-c1">6</span><span class="pl-k">,</span> <span class="pl-c1">7</span><span class="pl-k">,</span> <span class="pl-c1">8</span><span class="pl-k">,</span> <span class="pl-c1">9</span>]<span class="pl-k">;</span></pre></div>

<p>*<em>Note *</em>: la taille du tableau doit être explicite, sous peine de recevoir une erreur de la part du compilateur.</p>

<h3>
<a id="À-quoi-sert-le-mot-clé-super-" class="anchor" href="#%C3%80-quoi-sert-le-mot-cl%C3%A9-super-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>À quoi sert le mot-clé super ?</h3>

<p>Contrairement à ce que l'on pourrait croire, le mot-clé <code>super</code> ne représente pas une référence vers l'instance courante d'une classe mère, mais représente seulement le « scope » supérieur (dans un module).</p>

<p>Exemple :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">mod</span> mon_module {
    <span class="pl-k">pub</span> <span class="pl-k">fn</span> <span class="pl-en">ma_fonction</span>() {
        println<span class="pl-k">!</span>(<span class="pl-s">"Scope supérieur"</span>)<span class="pl-k">;</span>
    }

    <span class="pl-k">pub</span> <span class="pl-k">mod</span> fils {
        <span class="pl-k">pub</span> <span class="pl-k">fn</span> <span class="pl-en">fonction_enfant</span>() {
            <span class="pl-k">super</span><span class="pl-k">::</span><span class="pl-c1">ma_fonction</span>()<span class="pl-k">;</span>
        }
    }

    <span class="pl-k">pub</span> <span class="pl-k">mod</span> fille {
        <span class="pl-k">pub</span> <span class="pl-k">fn</span> <span class="pl-en">fonction_enfant</span>() {
            <span class="pl-k">super</span><span class="pl-k">::</span><span class="pl-c1">ma_fonction</span>()<span class="pl-k">;</span>
        }
    }
}

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    mon_module<span class="pl-k">::</span>fils<span class="pl-k">::</span><span class="pl-c1">fonction_enfant</span>()<span class="pl-k">;</span>
    mon_module<span class="pl-k">::</span>fille<span class="pl-k">::</span><span class="pl-c1">fonction_enfant</span>()<span class="pl-k">;</span>
}</pre></div>

<h3>
<a id="a-quoi-sert-le-mot-clé-self-" class="anchor" href="#a-quoi-sert-le-mot-cl%C3%A9-self-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert le mot-clé self ?</h3>

<p>Le mot-clé <code>self</code> renvoie à une copie (ou la référence (<code>&amp;self</code>)) de l'instance courante.</p>

<p>Il est souvent rencontré :</p>

<ul>
<li>lorsqu'une fonction virtuelle/abstraite est implémentée au sein d'une structure,</li>
<li>lorsque le développeur doit utiliser une fonction dans le module courant, </li>
<li>…</li>
</ul>

<p>Exemple :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">trait</span> <span class="pl-k">My_Trait</span> {
    <span class="pl-k">fn</span> <span class="pl-en">my_func</span>(<span class="pl-k">&amp;</span><span class="pl-v">self</span>)<span class="pl-k">;</span>
}

<span class="pl-k">mod</span> <span class="pl-k">My_Mod</span> {
    <span class="pl-k">fn</span> <span class="pl-en">foo</span>() {
        <span class="pl-v">self</span><span class="pl-k">::</span><span class="pl-c1">bar</span>()<span class="pl-k">;</span>
    }

    <span class="pl-k">fn</span> <span class="pl-en">bar</span>() {
    }
}</pre></div>

<p>Il sert aussi à désigner le module courant lors d'un import. Par exemple :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">use</span> std<span class="pl-k">::</span>io<span class="pl-k">::</span>{<span class="pl-v">self</span><span class="pl-k">,</span> <span class="pl-k">File</span>}<span class="pl-k">;</span>

<span class="pl-c">// maintenant on peut utiliser File mais aussi io !</span></pre></div>

<h3>
<a id="a-quoi-sert-le-mot-clé-use-" class="anchor" href="#a-quoi-sert-le-mot-cl%C3%A9-use-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert le mot-clé use ?</h3>

<p>Le mot-clé <code>use</code> permet de raccourcir le « chemin » des dépendences du programme, vous évitant ainsi d'expliciter les dépendences de chacune de vos ressources.</p>

<p>Exemple :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">extern</span> <span class="pl-k">crate</span> mon_package <span class="pl-k">;</span>

<span class="pl-k">use</span> mon_package<span class="pl-k">::</span>mon_module<span class="pl-k">::</span>ma_fonction <span class="pl-k">;</span>

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-c1">ma_fonction</span>() <span class="pl-k">;</span>
}</pre></div>

<p>Autrement dit, toute structure composée de différentes ressources peut être exploitée par le mot-clé <code>use</code>.</p>

<p>Exemple :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">enum</span> <span class="pl-k">MonEnum</span> {
    <span class="pl-k">Arg1</span><span class="pl-k">,</span>
    <span class="pl-k">Arg2</span><span class="pl-k">,</span>
}

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">use</span> <span class="pl-k">MonEnum</span><span class="pl-k">::</span>{<span class="pl-k">Arg1</span>}<span class="pl-k">;</span>
    <span class="pl-k">let</span> instance <span class="pl-k">=</span> <span class="pl-k">Arg1</span><span class="pl-k">;</span> <span class="pl-c">//plus la peine d'expliciter d'où provient l'instance Arg1 comme ceci:</span>
    <span class="pl-c">// let instance = MonEnum::Arg1;</span>
}</pre></div>

<p>Il permet aussi de réexporter des modules vers le scope supérieur. Prenons par un exemple un project possédant cette hiérarchie :</p>

<pre lang="text"><code>src
 ├─── fichier.rs
 ├─── video
 |      ├──── video.rs
 |      ├──── mod.rs
 |
 ├─── audio
        ├──── audio.rs
        ├──── mod.rs
</code></pre>

<p>Pour pouvoir accéder aux items présents dans <code>audio.rs</code> et <code>video.rs</code>, vous allez devoir les rendre visibles dans les niveaux supérieurs en les réexportant comme ceci :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-c">// dans video/mod.rs</span>
<span class="pl-k">pub</span> <span class="pl-k">use</span> <span class="pl-v">self</span><span class="pl-k">::</span>video<span class="pl-k">::</span>{<span class="pl-k">Video</span><span class="pl-k">,</span> une_fonction}<span class="pl-k">;</span>

<span class="pl-k">mod</span> video<span class="pl-k">;</span>

<span class="pl-c">// dans audio/mod.rs</span>
<span class="pl-k">pub</span> <span class="pl-k">use</span> <span class="pl-v">self</span><span class="pl-k">::</span>audio<span class="pl-k">::</span>{<span class="pl-k">Audio</span><span class="pl-k">,</span> une_autre_fonction}<span class="pl-k">;</span>

<span class="pl-k">mod</span> audio<span class="pl-k">;</span></pre></div>

<p>Dans <code>fichier.rs</code>, vous pourrez désormais faire :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">use</span> <span class="pl-k">Audio</span><span class="pl-k">;</span>
<span class="pl-k">use</span> <span class="pl-k">Video</span><span class="pl-k">;</span></pre></div>

<h3>
<a id="a-quoi-sert-le-mot-clé-pub-" class="anchor" href="#a-quoi-sert-le-mot-cl%C3%A9-pub-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert le mot-clé pub ?</h3>

<p>Le mot-clé <code>pub</code> peut être utilisé dans <em>trois</em> contextes différents :</p>

<ol>
<li>Au sein [et sur] des modules ;</li>
<li>Au sein [et sur] des traits ;</li>
<li>Au sein [et sur] des structures.</li>
</ol>

<p>Dans un premier temps, qu'il soit utilisé sur des <code>mod</code>ules, <code>trait</code>s, ou <code>struct</code>ures, il aura toujours la même fonction : rendre public l'objet concerné.</p>

<p>Exemple :</p>

<pre lang="text"><code>├── Cargo.lock
├── Cargo.toml
├── src
│   ├── lib.rs
│   └── main.rs
└── target
    └── debug
        ├── build
        ├── deps
        ├── examples
        ├── libmon_projet.rlib
        ├── mon_projet
        └── native
</code></pre>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">pub</span> <span class="pl-k">mod</span> ma_lib { <span class="pl-c">//la module représentant ma bibliothèque</span>
    <span class="pl-k">pub</span> <span class="pl-k">mod</span> mon_module { <span class="pl-c">// un module lambda</span>
        <span class="pl-k">pub</span> <span class="pl-k">fn</span> <span class="pl-en">ma_fonction</span>() { <span class="pl-c">//ma fonction</span>
            println<span class="pl-k">!</span>(<span class="pl-s">"Hi there !"</span>)<span class="pl-k">;</span>
        }
    }
}</pre></div>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">extern</span> <span class="pl-k">crate</span> mon_projet<span class="pl-k">;</span>

<span class="pl-k">use</span> mon_projet<span class="pl-k">::</span>ma_lib<span class="pl-k">::</span>mon_module<span class="pl-k">::</span>ma_fonction<span class="pl-k">;</span>

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-c1">ma_fonction</span>()<span class="pl-k">;</span>
}</pre></div>

<p>Renvoie :</p>

<pre lang="text"><code>Hi there !
</code></pre>

<p>« mon_projet » est le nom porté par votre projet dans le manifest Cargo.toml.</p>

<p>Pour cet exemple, voici le manifest rédigé :</p>

<div class="highlight highlight-source-toml"><pre>[<span class="pl-en">package</span>]
<span class="pl-smi">name</span> = <span class="pl-s"><span class="pl-pds">"</span>mon_projet<span class="pl-pds">"</span></span>
<span class="pl-smi">version</span> = <span class="pl-s"><span class="pl-pds">"</span>0.1.0<span class="pl-pds">"</span></span>
<span class="pl-smi">authors</span> = [<span class="pl-s"><span class="pl-pds">"</span>Songbird0 &lt;chaacygg@gmail.com&gt;<span class="pl-pds">"</span></span>]

[<span class="pl-en">dependencies</span>]</pre></div>

<p><strong>Comment faire une méthode statique ?</strong></p>

<p>Tout dépend de la présence de <code>self</code>/<code>&amp;self</code>/<code>&amp;mut self</code> en premier argument. Exemple :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">struct</span> <span class="pl-k">A</span><span class="pl-k">;</span>

<span class="pl-k">impl</span> <span class="pl-k">A</span> {
    <span class="pl-k">fn</span> <span class="pl-en">foo</span>() { <span class="pl-c">// ceci est une méthode statique</span>
    }

    <span class="pl-k">fn</span> <span class="pl-en">foo1</span>(arg<span class="pl-k">:</span> <span class="pl-k">i32</span>) { <span class="pl-c">// ceci est une méthode statique</span>
    }

    <span class="pl-k">fn</span> <span class="pl-en">foo2</span>(<span class="pl-k">&amp;</span><span class="pl-v">self</span>) { <span class="pl-c">// ceci n'est pas une méthode statique</span>
    }

    <span class="pl-k">fn</span> <span class="pl-en">foo3</span>(<span class="pl-v">self</span>) { <span class="pl-c">// ceci n'est pas une méthode statique non plus</span>
    }

    <span class="pl-k">fn</span> <span class="pl-en">foo4</span>(<span class="pl-k">&amp;</span><span class="pl-v">self</span><span class="pl-k">,</span> arg<span class="pl-k">:</span> <span class="pl-k">i32</span>) { <span class="pl-c">// ceci n'est pas non plus une méthode statique</span>
    }
}</pre></div>

<h3>
<a id="a-quoi-servent-les-mot-clés-extern-crate-" class="anchor" href="#a-quoi-servent-les-mot-cl%C3%A9s-extern-crate-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi servent les mot-clés extern crate ?</h3>

<p>Les mot-clés <code>extern crate</code> permettent d'importer un paquet entier de modules dans le fichier courant, aussi appelé crate.</p>

<p>Le principe est simple, il vous suffit seulement de créer en premier lieu un projet en mode « bibliothèque » pour réunir tous les modules que vous créerez, de créer un fichier qui accueillera le point d'entrée de votre programme, puis d'importer votre paquet.</p>

<p>Bien entendu, si vous souhaitez importer un paquet qui n'est pas de vous, il vous faudra l'inscrire dans votre manifest.</p>

<p>Voir aussi :</p>

<p>Pour voir un exemple de création de paquet, vous pouvez vous rendre à la Q/R : « <a href="#LII-A-16" title="A quoi sert le mot-clé pub ?">A quoi sert le mot-clé pub ?</a> »</p>

<p><a href="#comment-installer-de-nouvelles-biblioth%C3%A8ques">Comment installer de nouvelles bibliothèques ?</a></p>

<h3>
<a id="a-quoi-sert-le-mot-clé-mod-" class="anchor" href="#a-quoi-sert-le-mot-cl%C3%A9-mod-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert le mot-clé mod ?</h3>

<p>Le mot-clé <code>mod</code> vous permet d'importer ou de déclarer un module. Il est important de noter que les fichiers sont considérés comme des modules. Exemple :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">mod</span> a {
    <span class="pl-k">fn</span> <span class="pl-en">foo</span>() {}
}

<span class="pl-k">mod</span> nom_du_fichier<span class="pl-k">;</span> <span class="pl-c">// importera le fichier "nom_du_fichier.rs"</span></pre></div>

<p>Voir aussi :</p>

<p><a href="#a-quoi-sert-un-module">A quoi sert un module ?</a></p>

<h3>
<a id="a-quoi-sert-un-module-" class="anchor" href="#a-quoi-sert-un-module-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert un module ?</h3>

<p>Il vous permet de réunir plusieurs objets (<code>struct</code>ures, <code>trait</code>s, fonctions, d'autres <code>mod</code>ules…) dans un même fichier puis de les réutiliser à plusieurs endroits dans votre programme.</p>

<p>Voir aussi :</p>

<ul>
<li> <a href="#a-quoi-sert-le-mot-cl%C3%A9-pub">A quoi sert le mot-clé pub ?</a> </li>
<li> <a href="#a-quoi-servent-les-mot-cl%C3%A9s-extern-crate">A quoi servent les mot-clés extern crate ?</a> </li>
</ul>

<h3>
<a id="comment-créer-un-module-" class="anchor" href="#comment-cr%C3%A9er-un-module-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment créer un module ?</h3>

<p>Voici comment créer un <code>mod</code>ule :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">mod</span> <span class="pl-k">A</span> {
    <span class="pl-k">fn</span> <span class="pl-en">votre_fonction</span>() {}
    <span class="pl-k">fn</span> <span class="pl-en">une_autre_fonction</span>() {}

    <span class="pl-k">mod</span> <span class="pl-k">B</span> {
        <span class="pl-k">struct</span> <span class="pl-k">C</span><span class="pl-k">;</span>
        <span class="pl-k">trait</span> <span class="pl-k">D</span> {}
    }
}</pre></div>

<h3>
<a id="a-quoi-sert-le-mot-clé-type-" class="anchor" href="#a-quoi-sert-le-mot-cl%C3%A9-type-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert le mot-clé type ?</h3>

<p>Le mot-clé <code>type</code> permet de créer des <em>alias</em> et ainsi réduire la taille des types personnalisés (ou primitifs).</p>

<p>Voici un exemple :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">struct</span> <span class="pl-k">VeryLongTypeName</span><span class="pl-k">;</span>

<span class="pl-k">impl</span> <span class="pl-k">VeryLongTypeName</span> {
    <span class="pl-k">pub</span> <span class="pl-k">fn</span> <span class="pl-en">new</span>() <span class="pl-k">-&gt;</span> <span class="pl-k">VeryLongTypeName</span> {
        println<span class="pl-k">!</span>(<span class="pl-s">"In new function"</span>)<span class="pl-k">;</span>
        <span class="pl-k">return</span> <span class="pl-k">VeryLongTypeName</span><span class="pl-k">;</span>
    }
}

<span class="pl-k">type</span> <span class="pl-k">ShortName</span> <span class="pl-k">=</span> <span class="pl-k">VeryLongTypeName</span><span class="pl-k">;</span>

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo <span class="pl-k">=</span> <span class="pl-k">ShortName</span><span class="pl-k">::</span><span class="pl-c1">new</span>()<span class="pl-k">;</span>
}</pre></div>

<p>Liens :</p>

<p>Pour exécuter l'exemple de la Q/R, vous pouvez vous rendre <a href="https://is.gd/hPONv0" title="Rust Playground">ici</a>.</p>

<p>Retrouvez des explications <a href="http://stackoverflow.com/questions/29447920/what-is-the-rust-type-keyword" title="Post StackOverflow">ici</a>.</p>

<p><a href="http://rustbyexample.com/cast/alias.html" title="Rust by Example">Explications de la documentation officielle</a>.</p>

<h3>
<a id="a-quoi-sert-le-mot-clé-loop-" class="anchor" href="#a-quoi-sert-le-mot-cl%C3%A9-loop-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert le mot-clé loop ?</h3>

<p>Le mot-clé <code>loop</code> est un sucre syntaxique qui permet de remplacer le fameux :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">while</span>(<span class="pl-c1">true</span>) {

}

<span class="pl-c">// ou</span>

<span class="pl-k">for</span>(<span class="pl-k">;;</span>) {

}</pre></div>

<p>Préférez donc cette syntaxe :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">loop</span> {

}</pre></div>

<p>Liens :</p>

<p><a href="https://doc.rust-lang.org/book/loops.html#loop" title="Ancre vers le mot-clé loop">Documentation officielle</a>.</p>

<h3>
<a id="a-quoi-sert-le-mot-clé-where-" class="anchor" href="#a-quoi-sert-le-mot-cl%C3%A9-where-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert le mot-clé where ?</h3>

<p>Le mot-clé <code>where</code> permet de filtrer les objets passés en paramètres dans une fonction génériques, par exemple :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">trait</span> <span class="pl-k">Soldier</span>{}
<span class="pl-k">trait</span> <span class="pl-k">Citizen</span>{}

<span class="pl-k">struct</span> <span class="pl-k">A</span><span class="pl-k">;</span>
<span class="pl-k">struct</span> <span class="pl-k">B</span><span class="pl-k">;</span>

<span class="pl-k">impl</span> <span class="pl-k">Soldier</span> <span class="pl-k">for</span> <span class="pl-k">A</span> {}

<span class="pl-k">fn</span> <span class="pl-en">foo</span><span class="pl-k">&lt;</span><span class="pl-k">T</span><span class="pl-k">&gt;</span>(test<span class="pl-k">:</span> <span class="pl-k">T</span>) <span class="pl-k">-&gt;</span> <span class="pl-k">T</span>
<span class="pl-k">where</span> <span class="pl-k">T</span><span class="pl-k">:</span> <span class="pl-k">Soldier</span> {
    <span class="pl-k">return</span> test<span class="pl-k">;</span>
}

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> soldier<span class="pl-k">:</span> <span class="pl-k">A</span> <span class="pl-k">=</span> <span class="pl-k">A</span><span class="pl-k">;</span>
    <span class="pl-k">let</span> citizen<span class="pl-k">:</span> <span class="pl-k">B</span> <span class="pl-k">=</span> <span class="pl-k">B</span><span class="pl-k">;</span>
    <span class="pl-c1">foo</span>(soldier)<span class="pl-k">;</span>
    <span class="pl-c1">foo</span>(citizen)<span class="pl-k">;</span> <span class="pl-c">//error: the trait bound `B: Soldier` is not satisfied</span>
}</pre></div>

<h3>
<a id="a-quoi-sert-le-mot-clé-unsafe-" class="anchor" href="#a-quoi-sert-le-mot-cl%C3%A9-unsafe-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert le mot-clé unsafe ?</h3>

<p>Le mot-clé <code>unsafe</code> permet, comme son nom l'indique, de casser certaines règles natives de Rust pour effectuer des opérations « à risque ».</p>

<p>En pratique, le mot-clé <code>unsafe</code> permet une manipulation de la mémoire plus approfondie, plus directe, mais aussi plus compliquée, puisque le langage n'applique pas certaines règes.</p>

<p>Pour faire simple : utilisez <code>unsafe</code> aussi peu que possible.</p>

<p>Exemple d'utilisation d'<code>unsafe</code> :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">let</span> x<span class="pl-k">:</span> <span class="pl-k">i32</span> <span class="pl-k">=</span> <span class="pl-k">&amp;</span><span class="pl-c1">0</span><span class="pl-k">;</span>
<span class="pl-k">let</span> ptr <span class="pl-k">=</span> x <span class="pl-k">as</span> <span class="pl-k">*</span><span class="pl-k">const</span> <span class="pl-k">i32</span><span class="pl-k">;</span>
<span class="pl-k">unsafe</span> { <span class="pl-k">*</span>ptr<span class="pl-k">;</span> } <span class="pl-c">// on tente d'accéder à l'élément pointé par le pointeur, ce qui est hautement "unsafe"</span></pre></div>

<p>Voir aussi :</p>

<p><a href="#quelles-sont-les-r%C3%A8gles-non-appliqu%C3%A9es-dans-ces-contextes">Quelles sont les règles non-appliquées dans ces contextes ?</a></p>

<p><a href="#quels-comportements-sont-consid%C3%A9r%C3%A9s-non-s%C3%BBrs-par-rust">Quels comportements sont considérés « non-sûrs » par Rust ?</a></p>

<h3>
<a id="quelles-sont-les-règles-non-appliquées-dans-ces-contextes-" class="anchor" href="#quelles-sont-les-r%C3%A8gles-non-appliqu%C3%A9es-dans-ces-contextes-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quelles sont les règles non-appliquées dans ces contextes ?</h3>

<p>Trois règles, et seulement trois, sont brisées dans les blocs (et fonctions) <code>unsafe</code>:</p>

<ol>
<li>L'accès et la modification d'une variable globale (statique) mutable sont autorisés ;</li>
<li>Il est possible de déréférencer un pointeur (non-nul, donc) ;</li>
<li>Il est possible de faire à une fonction non-sûre.</li>
</ol>

<h3>
<a id="quels-comportements-sont-considérés--non-sûrs--par-rust-" class="anchor" href="#quels-comportements-sont-consid%C3%A9r%C3%A9s--non-s%C3%BBrs--par-rust-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quels comportements sont considérés « non-sûrs » par Rust ?</h3>

<p>Pour en retrouver une liste exhaustive, rendez-vous à la <a href="https://doc.rust-lang.org/book/unsafe.html#what-does-safe-mean" title="Ouvrir un nouvel onglet">section dédiée</a>.</p>

<h3>
<a id="a-quoi-sert-le-mot-clé-fn-" class="anchor" href="#a-quoi-sert-le-mot-cl%C3%A9-fn-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert le mot-clé fn ?</h3>

<p>En rust, pour déclarer une fonction, il faut utiliser le mot-clé <code>fn</code> :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">ma_fonction</span>() {

}</pre></div>

<h3>
<a id="a-quoi-sert-le-mot-clé-match-" class="anchor" href="#a-quoi-sert-le-mot-cl%C3%A9-match-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert le mot-clé match ?</h3>

<p>Le mot-clé <code>match</code> nous permet d'implémenter le <em>pattern</em> <em>matching</em>.</p>

<p>Ainsi, il est possible de comparer une entrée à plusieurs tokens constants et agir en conséquence. Le pattern matching est considéré comme un test <em>exhaustif</em>, car, quoi qu'il arrive, il fera en sorte de couvrir tous les cas de figure qu'on lui propose.</p>

<p>Exemple :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">i32</span> <span class="pl-k">=</span> <span class="pl-c1">117</span><span class="pl-k">;</span>

<span class="pl-k">match</span> foo {
    <span class="pl-c1">117</span> <span class="pl-k">=&gt;</span> println<span class="pl-k">!</span>(<span class="pl-s">"foo's value equals 117 !"</span>)<span class="pl-k">,</span>
    <span class="pl-k">_</span> <span class="pl-k">=&gt;</span> println<span class="pl-k">!</span>(<span class="pl-s">"You know nothing, John."</span>)<span class="pl-k">,</span> <span class="pl-c">// s'efforcera de trouver une réponse</span>
}</pre></div>

<p>Jusqu'ici, il semblerait que le mot-clé <code>match</code> ne soit pas capable de faire preuve de plus de souplesse qu'un <code>switch</code>, ce qui est bien entendu le contraire ! Vous pouvez par-exemple matcher sur un ensemble de valeur :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">i32</span> <span class="pl-k">=</span> <span class="pl-c1">117</span><span class="pl-k">;</span>

<span class="pl-k">match</span> foo {
    <span class="pl-c1">100</span><span class="pl-k">...</span><span class="pl-c1">120</span> <span class="pl-k">=&gt;</span> println<span class="pl-k">!</span>(<span class="pl-s">"foo's value equals est entre 100 et 120 !"</span>)<span class="pl-k">,</span>
    <span class="pl-k">_</span> <span class="pl-k">=&gt;</span> println<span class="pl-k">!</span>(<span class="pl-s">"You know nothing, John."</span>)<span class="pl-k">,</span> <span class="pl-c">// s'efforcera de trouver une réponse</span>
}</pre></div>

<p>Le pattern matching est très puissant, n'hésitez pas à en user et en abuser !</p>

<p>Voir aussi :</p>

<p>Vous pouvez exécuter l'exemple <a href="https://is.gd/otk1eC">ici</a>.</p>

<p>Vous pouvez retrouver <a href="https://en.wikipedia.org/wiki/Pattern_matching">une source</a> abordant le pattern matching. (avec plusieurs exemples)</p>

<p><a href="https://doc.rust-lang.org/book/match.html">Partie de la documentation officielle abordant l'implémentation du pattern matching</a>.</p>

<h3>
<a id="a-quoi-sert-le-mot-clé-ref-" class="anchor" href="#a-quoi-sert-le-mot-cl%C3%A9-ref-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert le mot-clé ref ?</h3>

<p>Le mot-clé <code>ref</code> est une alternative au caractère spécial <code>&amp;</code> pour expliciter le renvoie d'une référence d'un objet :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">struct</span> <span class="pl-k">A</span><span class="pl-k">;</span>

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">A</span> <span class="pl-k">=</span> <span class="pl-k">A</span> <span class="pl-k">;</span>
    <span class="pl-k">let</span> bar<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">A</span> <span class="pl-k">=</span> <span class="pl-k">&amp;</span>foo <span class="pl-k">;</span> <span class="pl-c">// ou let ref bar = foo ;</span>
}</pre></div>

<h3>
<a id="a-quoi-sert-le-mot-clé-mut-" class="anchor" href="#a-quoi-sert-le-mot-cl%C3%A9-mut-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert le mot-clé mut ?</h3>

<p>Le mot-clé <code>mut</code> permet de rendre l'une de vos variable muables lors de sa déclaration.</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">let</span> <span class="pl-k">mut</span> foo<span class="pl-k">:</span> <span class="pl-k">i32</span> <span class="pl-k">=</span> <span class="pl-c1">0</span> <span class="pl-k">;</span>
<span class="pl-k">let</span> bar<span class="pl-k">:</span> <span class="pl-k">i32</span> <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">;</span>
foo <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">;</span>
bar <span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-k">;</span> <span class="pl-c">//erreur</span></pre></div>

<h3>
<a id="une-erreur-survient-lorsque-que-je-modifie-le-contenu-de-ma-variable--que-faire-" class="anchor" href="#une-erreur-survient-lorsque-que-je-modifie-le-contenu-de-ma-variable--que-faire-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Une erreur survient lorsque que je modifie le contenu de ma variable ! Que faire ?</h3>

<p>Il se peut que vous ayez omis la particularité de Rust : tout est immuable par défaut.</p>

<p>Pour permettre à une variable de modifier son contenu, il vous faudra utiliser le mot-clé <code>mut</code>.</p>

<p>Voir aussi : <a href="#a-quoi-sert-le-mot-cl%C3%A9-mut">A quoi sert le mot-clé mut ?</a></p>

<h3>
<a id="quest-ce-quune-macro-" class="anchor" href="#quest-ce-quune-macro-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Qu'est-ce qu'une macro ?</h3>

<p>Une macro est ce que l'on peut appeler vulgairement : une fonction très puissante.</p>

<p>Grâce aux macros, nous pouvons capturer <em>plusieurs</em> groupes <em>d'expressions</em> et ainsi écrire les instructions désirées selon <em>chaque</em> cas.</p>

<p>Pour grossir un peu le trait : les macros sont une extension du compilateur de Rust. Elles sont interprétées au moment de la compilation, pas pendant l'exécution de votre programme.</p>

<p>Voir aussi : <a href="#comment-utiliser-une-macro">Comment utiliser une macro ?</a></p>

<h3>
<a id="comment-utiliser-une-macro-" class="anchor" href="#comment-utiliser-une-macro-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment utiliser une macro ?</h3>

<p>Pour utiliser une macro, il faut d'abord la déclarer en utilisant le mot-clé <code>macro_rules!</code>.</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">macro_rules!</span> <span class="pl-en">foo</span>
{
    () <span class="pl-k">=&gt;</span> ()<span class="pl-k">;</span>
}</pre></div>

<p>Toutes les macros (y compris celle présentée ici) respectent une règle très importante : elles doivent toutes capturer au moins une expression pour être valide et compilées. (en l'occurrence, la regex <code>() =&gt; () ;</code>)</p>

<p>C'est donc cela, l'une des différences majeures entre une fonction/procédure et une macro : cette dernière est capable de capturer des expressions rationnelles, conserver en mémoire ce que désire le développeur, puis de les ré-utiliser dans le corps de l'une d'entre-elles.</p>

<p>Ces « super » fonctions demandent donc quelques notions liées aux expressions rationnelles pour vous permettre d'apprécier pleinement ce puissant mécanisme.</p>

<p>Voici un exemple très basique de macro :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-c">/// **Attention**:</span>
<span class="pl-c">/// </span>
<span class="pl-c">/// Cette macro n'utilise qu'un seul type de spécificateur, mais il en existe beaucoup d'autres.</span>
<span class="pl-k">macro_rules!</span> <span class="pl-en">foo</span>
{
    (<span class="pl-k">$</span>your_name<span class="pl-k">:</span>expr<span class="pl-k">,</span> <span class="pl-k">$</span>your_last_name<span class="pl-k">:</span>expr<span class="pl-k">,</span> <span class="pl-k">$</span>carriage_return<span class="pl-k">:</span> expr) <span class="pl-k">=&gt;</span>
    {
        <span class="pl-k">if</span> <span class="pl-k">$</span>carriage_return <span class="pl-k">==</span> <span class="pl-c1">true</span>
        {
            println<span class="pl-k">!</span>(<span class="pl-s">"My name's {} {}."</span><span class="pl-k">,</span> <span class="pl-k">$</span>your_name<span class="pl-k">,</span> <span class="pl-k">$</span>your_last_name)<span class="pl-k">;</span> 
        }
        <span class="pl-k">else</span> { print<span class="pl-k">!</span>(<span class="pl-s">"My name's {} {}."</span><span class="pl-k">,</span> <span class="pl-k">$</span>your_name<span class="pl-k">,</span> <span class="pl-k">$</span>your_last_name)<span class="pl-k">;</span> }
    }<span class="pl-k">;</span>

    (<span class="pl-k">$</span>your_name<span class="pl-k">:</span>expr<span class="pl-k">,</span> <span class="pl-k">$</span>your_last_name<span class="pl-k">:</span>expr) <span class="pl-k">=&gt;</span>
    {
        foo<span class="pl-k">!</span>(<span class="pl-k">$</span>your_name<span class="pl-k">,</span> <span class="pl-k">$</span>your_last_name<span class="pl-k">,</span> <span class="pl-c1">false</span>)<span class="pl-k">;</span>
    }<span class="pl-k">;</span>

    (<span class="pl-k">$</span>your_name<span class="pl-k">:</span>expr) <span class="pl-k">=&gt;</span>
    {
        foo<span class="pl-k">!</span>(<span class="pl-k">$</span>your_name<span class="pl-k">,</span> <span class="pl-s">""</span><span class="pl-k">,</span> <span class="pl-c1">false</span>)<span class="pl-k">;</span>
    }<span class="pl-k">;</span>
}

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    foo<span class="pl-k">!</span>(<span class="pl-s">"Song"</span><span class="pl-k">,</span> <span class="pl-s">"Bird"</span><span class="pl-k">,</span> <span class="pl-c1">true</span>)<span class="pl-k">;</span>
    foo<span class="pl-k">!</span>(<span class="pl-s">"Song"</span><span class="pl-k">,</span> <span class="pl-s">"Bird"</span>)<span class="pl-k">;</span> <span class="pl-c">// pas de retour à la ligne</span>
    foo<span class="pl-k">!</span>(<span class="pl-s">"Song"</span>)<span class="pl-k">;</span> <span class="pl-c">// là non plus</span>
}</pre></div>

<p>Vous aurez certainement remarqué que les paramètres passés sont assez spéciaux ; Au lieu d'avoir le nom de leur type après les deux points (« : »), il est écrit <code>expr</code>.</p>

<p>C'est ce que l'on appelle un « spécificateur » .</p>

<p>Liens :</p>

<p><a href="https://is.gd/nHfcEQ" title="Exemple d'utilisation d'une macro">Visionner le résultat de cet exemple.</a></p>

<p><a href="">Que sont les spécificateurs ?</a></p>

<h3>
<a id="que-sont-les-spécificateurs-" class="anchor" href="#que-sont-les-sp%C3%A9cificateurs-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Que sont les spécificateurs ?</h3>

<h3>
<a id="À-quoi-sert-le-mot-clé-usize-" class="anchor" href="#%C3%80-quoi-sert-le-mot-cl%C3%A9-usize-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>À quoi sert le mot-clé usize ?</h3>

<p>Le mot-clé <code>usize</code> permet de laisser le compilateur choisir la taille en mémoire d'un entier <em>non-signé</em> (selon l'architecture de la machine sur laquelle le programme sera exécuté).</p>

<p>Voir aussi : <a href="#a-quoi-sert-le-mot-cl%C3%A9-isize">A quoi sert le mot-clé isize ?</a></p>

<h3>
<a id="a-quoi-sert-le-mot-clé-isize-" class="anchor" href="#a-quoi-sert-le-mot-cl%C3%A9-isize-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert le mot-clé isize ?</h3>

<p>Le mot-clé <code>isize</code> permet de laisser le compilateur choisir la taille en mémoire d'un entier <em>signé</em> (selon l'architecture de la machine sur laquelle le programme sera exécuté).</p>

<p>Voir aussi : <a href="#%C3%80-quoi-sert-le-mot-cl%C3%A9-usize">A quoi sert le mot-clé usize ?</a></p>

<h3>
<a id="existe-t-il-des-outils-de-build-pour-le-langage-rust-" class="anchor" href="#existe-t-il-des-outils-de-build-pour-le-langage-rust-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Existe-t-il des outils de build pour le langage Rust ?</h3>

<p>Rust dispose d'un outil de développement multifonction nommé Cargo.</p>

<p>Cargo est en premier lieu un gestionnaire de paquets (qui vous permet donc de télécharger des modules Rust développés par d'autres programmeurs) mais vous épaule également dans la gestion, la construction de vos projets, la création de vos manifest, etc...</p>

<p>Un groupe de Q/R a été créé sur cette FAQ présentant une liste non-exhaustive de commandes supportées par Cargo suivie d'un exemple d'utilisation (vous pourrez également retrouver des exemples dans le manuel officiel de l'outil (<code>$ man cargo</code>)) :</p>

<ul>
<li> <a href="#comment-cr%C3%A9er-un-projet-avec-cargo">Comment créer un projet avec Cargo ?</a> </li>
<li> <a href="#quel-type-de-projet-puis-je-cr%C3%A9er-avec-cargo">Quel type de projet puis-je créer avec Cargo ?</a> </li>
<li> <a href="#comment-compiler-son-projet">Comment compiler son projet ?</a> </li>
<li> <a href="#peut-on-g%C3%A9n%C3%A9rer-de-la-documentation-avec-cargo">Peut-on générer de la documentation avec Cargo ?</a> </li>
<li> <a href="#o%C3%B9-trouver-de-nouvelles-biblioth%C3%A8ques">Où trouver de nouvelles bibliothèques ?</a> </li>
<li> <a href="#comment-installer-de-nouvelles-biblioth%C3%A8ques">Comment installer de nouvelles bibliothèques ?</a> </li>
<li> <a href="#comment-publier-sa-biblioth%C3%A8que-faite-maison">Comment publier sa bibliothèque faite-maison ?</a> </li>
<li> <a href="#comment-lancer-des-tests-avec-cargo">Comment lancer des tests avec Cargo ?</a> </li>
<li> <a href="#comment-cr%C3%A9er-ses-benchmarks-avec-cargo">Comment créer ses benchmarks avec Cargo ?</a> </li>
<li> <a href="#comment-mettre-%C3%A0-jour-mes-biblioth%C3%A8ques">Comment mettre à jour mes bibliothèques ?</a> </li>
</ul>

<h3>
<a id="comment-utiliser-mes-fonctions-en-dehors-de-mon-module-" class="anchor" href="#comment-utiliser-mes-fonctions-en-dehors-de-mon-module-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment utiliser mes fonctions en dehors de mon module ?</h3>

<p>Pour utiliser vos fonctions en dehors de votre <code>mod</code>ule, il vous faudra utiliser le mot-clé <code>pub</code>.</p>

<p>Voir aussi :</p>

<p><a href="#a-quoi-sert-le-mot-cl%C3%A9-pub">A quoi sert le mot-clé pub ?</a></p>

<p><a href="#a-quoi-servent-les-mot-cl%C3%A9s-extern-crate">A quoi servent les mot-clés extern crate ?</a></p>

<h3>
<a id="comment-comparer-deux-objets-avec-rust-" class="anchor" href="#comment-comparer-deux-objets-avec-rust-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment comparer deux objets avec Rust ?</h3>

<p>Pour comparer deux objets avec Rust, vous pouvez implémenter le <code>trait</code> <code>PartialEq</code> que vous pourrez ensuite utiliser avec <code>==</code> ou la méthode <code>eq</code>.</p>

<p>Exemple :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">;</span>
    <span class="pl-k">let</span> bar <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">;</span>
    <span class="pl-k">let</span> baz <span class="pl-k">=</span> foo <span class="pl-k">==</span> bar<span class="pl-k">;</span> <span class="pl-c">//true</span>

    <span class="pl-k">let</span> bazz <span class="pl-k">=</span> <span class="pl-s">"Hello world !"</span><span class="pl-k">;</span>
    <span class="pl-k">let</span> bazzz <span class="pl-k">=</span> <span class="pl-s">"Hello world !"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">;</span>
    <span class="pl-k">let</span> bazzzz <span class="pl-k">=</span> bazz <span class="pl-k">==</span> <span class="pl-k">&amp;</span>bazzz<span class="pl-k">;</span> <span class="pl-c">// true</span>
    <span class="pl-k">let</span> bazzzz <span class="pl-k">=</span> bazz<span class="pl-k">.</span><span class="pl-c1">eq</span>(<span class="pl-k">&amp;</span>bazzz)<span class="pl-k">;</span> <span class="pl-c">// équivalent de la ligne du dessus</span>
}</pre></div>

<p>Voir aussi : <a href="#comment-comparer-deux-objets-dune-structure-personnalis%C3%A9e-avec-rust">Comment comparer deux objets d'une structure personnalisée avec Rust ?</a></p>

<h3>
<a id="quest-ce-que-le-shadowing-" class="anchor" href="#quest-ce-que-le-shadowing-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Qu'est-ce que le shadowing ?</h3>

<p>Le shadowing consiste à faire abstraction des identificateurs qui pourraient être identiques à ceux se trouvant dans un scope (« champ ») plus petit, ou étranger à celui des autres identificateurs dans l'absolu.</p>

<p>Exemple :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">str</span> <span class="pl-k">=</span> <span class="pl-s">"Hello"</span><span class="pl-k">;</span>
    {
        <span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">str</span> <span class="pl-k">=</span> <span class="pl-s">"world!"</span><span class="pl-k">;</span>
        println<span class="pl-k">!</span>(<span class="pl-s">"{}"</span><span class="pl-k">,</span> <span class="pl-k">&amp;</span>foo)<span class="pl-k">;</span>
    }
    println<span class="pl-k">!</span>(<span class="pl-s">"{}"</span><span class="pl-k">,</span> <span class="pl-k">&amp;</span>foo)<span class="pl-k">;</span>
}</pre></div>

<p>La première déclaration de foo a été « éclipsée » par celle se trouvant dans le deuxième scope. Lorsque cette dernière a été détruite, la première déclaration de <code>foo</code> a été de nouveau opérationnelle.</p>

<p>Résultat :</p>

<div class="highlight highlight-source-rust"><pre>world<span class="pl-k">!</span>
<span class="pl-k">Hello</span></pre></div>

<h3>
<a id="quest-ce-que-la-destructuration-" class="anchor" href="#quest-ce-que-la-destructuration-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Qu'est-ce que la destructuration ?</h3>

<p>Avec Rust, il est possible d'effectuer une « destructuration » sur certains types de données, mais qu'est-ce que cela signifie exactement ?</p>

<p>Grâce au pattern matching, il est possible de créer, donc, des « modèles » pour isoler une partie de la structure et ainsi vérifier si notre entrée correspond à nos attentes.</p>

<p>Une destrucuration peut se faire sur :</p>

<ul>
<li>Les listes</li>
<li>Les tuples</li>
<li>Les énumérations</li>
<li>Les structures</li>
</ul>

<p>Voir aussi :</p>

<ul>
<li> <a href="#comment-effectuer-une-destructuration-sur-une-liste">Comment effectuer une destructuration sur une liste ?</a> </li>
<li> <a href="#comment-effectuer-une-destructuration-sur-une-%C3%A9num%C3%A9ration">Comment effectuer une destructuration sur une énumération ?</a> </li>
<li> <a href="#comment-effectuer-une-destructuration-sur-une-structure">Comment effectuer une destructuration sur une structure ?</a> </li>
</ul>

<h3>
<a id="comment-effectuer-une-destructuration-sur-une-liste-" class="anchor" href="#comment-effectuer-une-destructuration-sur-une-liste-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment effectuer une destructuration sur une liste ?</h3>

<p>Pour isoler une valeur contenu dans un tuple, il faut d'abord écrire son modèle pour savoir où le chercher.</p>

<p>Par exemple, en assumant que nous cherchons une suite de chiffres dans un ordre croissant, il est simple de déterminer si cette suite est dans le bon ordre ou non.</p>

<div class="highlight highlight-source-rust"><pre>    <span class="pl-k">let</span> foo <span class="pl-k">=</span> (<span class="pl-s">"one"</span><span class="pl-k">,</span> <span class="pl-s">"two"</span><span class="pl-k">,</span> <span class="pl-s">"three"</span>)<span class="pl-k">;</span>
    <span class="pl-k">let</span> bar <span class="pl-k">=</span> (<span class="pl-s">"two"</span><span class="pl-k">,</span> <span class="pl-s">"one"</span><span class="pl-k">,</span> <span class="pl-s">"three"</span>)<span class="pl-k">;</span> 

    <span class="pl-k">match</span> bar {
        (<span class="pl-s">"one"</span><span class="pl-k">,</span> x<span class="pl-k">,</span> <span class="pl-s">"three"</span>) <span class="pl-k">=&gt;</span> {
            <span class="pl-k">if</span> x <span class="pl-k">==</span> <span class="pl-s">"two"</span> {
                println<span class="pl-k">!</span>(<span class="pl-s">"tout est en ordre !"</span>)<span class="pl-k">;</span>
            }
        }
        <span class="pl-k">_</span> <span class="pl-k">=&gt;</span> println<span class="pl-k">!</span>(<span class="pl-s">"on dirait qu'il y a un problème dans votre tuple..."</span>)<span class="pl-k">,</span>
    }</pre></div>

<p>Lorsque vous construisez un modèle de ce type, gardez bien en tête que la valeur la plus à gauche représentera toujours la première valeur du tuple, et celle plus à droite représentera toujours la dernière valeur du tuple.</p>

<p>Rien ne vous empêche donc de faire ceci :</p>

<div class="highlight highlight-source-rust"><pre>    <span class="pl-k">let</span> foo <span class="pl-k">=</span> (<span class="pl-s">"one"</span><span class="pl-k">,</span> <span class="pl-s">"two"</span><span class="pl-k">,</span> <span class="pl-s">"three"</span>)<span class="pl-k">;</span>
    <span class="pl-k">let</span> bar <span class="pl-k">=</span> (<span class="pl-s">"two"</span><span class="pl-k">,</span> <span class="pl-s">"one"</span><span class="pl-k">,</span> <span class="pl-s">"three"</span>)<span class="pl-k">;</span> 

    <span class="pl-k">match</span> foo {
        (<span class="pl-s">"one"</span><span class="pl-k">,</span> x<span class="pl-k">,</span> y) <span class="pl-k">=&gt;</span> {
            <span class="pl-k">if</span> (x<span class="pl-k">,</span> y) <span class="pl-k">==</span> (<span class="pl-s">"two"</span><span class="pl-k">,</span> <span class="pl-s">"three"</span>) { <span class="pl-c">// on surveille plusieurs valeurs</span>
                println<span class="pl-k">!</span>(<span class="pl-s">"tout est en ordre !"</span>)<span class="pl-k">;</span>
            }
        }<span class="pl-k">,</span>
        <span class="pl-k">_</span> <span class="pl-k">=&gt;</span> println<span class="pl-k">!</span>(<span class="pl-s">"on dirait qu'il y a un problème dans votre tuple..."</span>)<span class="pl-k">,</span>
    }</pre></div>

<h3>
<a id="comment-effectuer-une-destructuration-sur-une-énumération-" class="anchor" href="#comment-effectuer-une-destructuration-sur-une-%C3%A9num%C3%A9ration-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment effectuer une destructuration sur une énumération ?</h3>

<p>Le pattern matching vous donne la possibilité de « décortiquer » une énumération, vous permettant ainsi d'effectuer des tests complets.</p>

<p>Voici un exemple :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">pub</span> <span class="pl-k">enum</span> <span class="pl-k">Enum</span> {
    <span class="pl-k">One</span><span class="pl-k">,</span>
    <span class="pl-k">Two</span><span class="pl-k">,</span>
    <span class="pl-k">Three</span><span class="pl-k">,</span>
    <span class="pl-k">Four</span><span class="pl-k">,</span>
}

<span class="pl-k">fn</span> <span class="pl-en">foo</span>(arg<span class="pl-k">:</span> <span class="pl-k">Enum</span>) {
    <span class="pl-k">match</span> arg {
        <span class="pl-k">Enum</span><span class="pl-k">::</span><span class="pl-k">One</span> <span class="pl-k">=&gt;</span>  println<span class="pl-k">!</span>(<span class="pl-s">"One"</span>)<span class="pl-k">,</span>
        <span class="pl-k">Enum</span><span class="pl-k">::</span><span class="pl-k">Two</span> <span class="pl-k">=&gt;</span> println<span class="pl-k">!</span>(<span class="pl-s">"Two"</span>)<span class="pl-k">,</span>
        <span class="pl-k">Enum</span><span class="pl-k">::</span><span class="pl-k">Three</span> <span class="pl-k">=&gt;</span> println<span class="pl-k">!</span>(<span class="pl-s">"Three"</span>)<span class="pl-k">,</span>
        <span class="pl-k">Enum</span><span class="pl-k">::</span><span class="pl-k">Four</span> <span class="pl-k">=&gt;</span> println<span class="pl-k">!</span>(<span class="pl-s">"Four"</span>)<span class="pl-k">,</span>
    }
}

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> (bar<span class="pl-k">,</span> baz<span class="pl-k">,</span> bazz<span class="pl-k">,</span> bazzz) <span class="pl-k">=</span> (<span class="pl-k">Enum</span><span class="pl-k">::</span><span class="pl-k">One</span><span class="pl-k">,</span> <span class="pl-k">Enum</span><span class="pl-k">::</span><span class="pl-k">Two</span><span class="pl-k">,</span> <span class="pl-k">Enum</span><span class="pl-k">::</span><span class="pl-k">Three</span><span class="pl-k">,</span> <span class="pl-k">Enum</span><span class="pl-k">::</span><span class="pl-k">Four</span>)<span class="pl-k">;</span>

    <span class="pl-c1">foo</span>(bar)<span class="pl-k">;</span>
    <span class="pl-c1">foo</span>(baz)<span class="pl-k">;</span>
    <span class="pl-c1">foo</span>(bazz)<span class="pl-k">;</span>
    <span class="pl-c1">foo</span>(bazzz)<span class="pl-k">;</span>
}</pre></div>

<h3>
<a id="comment-effectuer-une-destructuration-sur-une-structure-" class="anchor" href="#comment-effectuer-une-destructuration-sur-une-structure-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment effectuer une destructuration sur une structure ?</h3>

<p>Tout d'abord, la question que nous pourrions nous poser est : en quoi consiste la destructuration sur une structure ?</p>

<p>L'idée est d'isoler, encore une fois, les propriétés qui nous intéressent.</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">struct</span> <span class="pl-k">A</span> {
    x<span class="pl-k">:</span> <span class="pl-k">String</span><span class="pl-k">,</span>
    y<span class="pl-k">:</span> <span class="pl-k">String</span><span class="pl-k">,</span>
    z<span class="pl-k">:</span> <span class="pl-k">String</span><span class="pl-k">,</span>
}

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo <span class="pl-k">=</span> <span class="pl-k">A</span> {
        x<span class="pl-k">:</span> <span class="pl-s">"Hello"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">,</span>
        y<span class="pl-k">:</span> <span class="pl-s">" "</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">,</span>
        z<span class="pl-k">:</span> <span class="pl-s">"world!"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">,</span>
    }<span class="pl-k">;</span>
    <span class="pl-k">let</span> <span class="pl-k">A</span> { x<span class="pl-k">:</span> a<span class="pl-k">,</span> y<span class="pl-k">:</span> b<span class="pl-k">,</span> z<span class="pl-k">:</span> c } <span class="pl-k">=</span> foo<span class="pl-k">;</span> <span class="pl-c">// on décortique les attributs de notre structure</span>
    println<span class="pl-k">!</span>(<span class="pl-s">"{}{}{}"</span><span class="pl-k">,</span> a<span class="pl-k">,</span> b<span class="pl-k">,</span> c)<span class="pl-k">;</span> <span class="pl-c">// puis on les utilise dans de nouvelles variables</span>
}</pre></div>

<p>Vous souhaiteriez omettre un attribut ? Pas de problèmes !</p>

<div class="highlight highlight-source-rust"><pre>    <span class="pl-k">let</span> foo <span class="pl-k">=</span> <span class="pl-k">A</span> {
        x<span class="pl-k">:</span> <span class="pl-s">"Hello"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">,</span>
        y<span class="pl-k">:</span> <span class="pl-s">" "</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">,</span>
        z<span class="pl-k">:</span> <span class="pl-s">"world!"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">,</span>
    }<span class="pl-k">;</span>
    <span class="pl-k">let</span> <span class="pl-k">A</span> { x<span class="pl-k">:</span> a<span class="pl-k">,</span> y<span class="pl-k">:</span> b<span class="pl-k">,</span> <span class="pl-k">..</span> } <span class="pl-k">=</span> foo<span class="pl-k">;</span> <span class="pl-c">// on décortique les attributs de notre structure</span>
    println<span class="pl-k">!</span>(<span class="pl-s">"{}{}"</span><span class="pl-k">,</span> a<span class="pl-k">,</span> b)<span class="pl-k">;</span> <span class="pl-c">// puis on les utilise dans de nouvelles variables</span></pre></div>

<p>Vous pouvez également isoler ce style d'opération dans un scope plus petit (empêchant l'utilisation des variables temporaires en dehors de ce dernier) comme ceci :</p>

<div class="highlight highlight-source-rust"><pre>    <span class="pl-k">let</span> foo <span class="pl-k">=</span> <span class="pl-k">A</span> {
        x<span class="pl-k">:</span> <span class="pl-s">"Hello"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">,</span>
        y<span class="pl-k">:</span> <span class="pl-s">" "</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">,</span>
        z<span class="pl-k">:</span> <span class="pl-s">"world!"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">,</span>
    }<span class="pl-k">;</span>
    {
        <span class="pl-k">let</span> <span class="pl-k">A</span> { x<span class="pl-k">:</span> a<span class="pl-k">,</span> y<span class="pl-k">:</span> b<span class="pl-k">,</span> z<span class="pl-k">:</span> c } <span class="pl-k">=</span> foo<span class="pl-k">;</span> <span class="pl-c">//on décortique les attributs de notre structure</span>
        println<span class="pl-k">!</span>(<span class="pl-s">"{}{}{}"</span><span class="pl-k">,</span> a<span class="pl-k">,</span> b<span class="pl-k">,</span> c)<span class="pl-k">;</span> <span class="pl-c">//puis on les utilise dans de nouvelles variables</span>
    }

    <span class="pl-c">// a,b et c ne pourront plus être utilisés à partir d'ici</span></pre></div>

<h3>
<a id="comment-comparer-deux-objets-dune-structure-personnalisée-avec-rust-" class="anchor" href="#comment-comparer-deux-objets-dune-structure-personnalis%C3%A9e-avec-rust-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment comparer deux objets d'une structure personnalisée avec Rust ?</h3>

<p>La bibliothèque standard de Rust propose un(e) <code>trait</code>/ interface nommé(e) <code>PartialEq</code> composée de deux fonctions :</p>

<ol>
<li> <code>fn eq(&amp;self, other : &amp;instance_de_la_meme_structure)</code> * ;* </li>
<li> <code>fn ne(&amp;self, other : &amp;instance_de_la_meme_structure)</code> <em>;</em> </li>
</ol>

<p>Ci-dessous figure un exemple complet d'implémentation :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">struct</span> <span class="pl-k">Spartan</span><span class="pl-k">&lt;</span><span class="pl-k">'a</span><span class="pl-k">&gt;</span> {
    sid<span class="pl-k">:</span> <span class="pl-k">i32</span><span class="pl-k">,</span> 
    name<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">'a</span> <span class="pl-k">str</span><span class="pl-k">,</span>
}

<span class="pl-k">impl</span><span class="pl-k">&lt;</span><span class="pl-k">'a</span><span class="pl-k">&gt;</span> <span class="pl-k">PartialEq</span> <span class="pl-k">for</span> <span class="pl-k">Spartan</span><span class="pl-k">&lt;</span><span class="pl-k">'a</span><span class="pl-k">&gt;</span> {
    <span class="pl-k">fn</span> <span class="pl-en">eq</span>(<span class="pl-k">&amp;</span><span class="pl-v">self</span><span class="pl-k">,</span> other<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">Spartan</span>) <span class="pl-k">-&gt;</span> <span class="pl-k">bool</span> {
        <span class="pl-v">self</span><span class="pl-k">.</span>sid <span class="pl-k">==</span> other<span class="pl-k">.</span>sid
    }
}

<span class="pl-k">impl</span><span class="pl-k">&lt;</span><span class="pl-k">'a</span><span class="pl-k">&gt;</span> <span class="pl-k">Spartan</span><span class="pl-k">&lt;</span><span class="pl-k">'a</span><span class="pl-k">&gt;</span> {
    <span class="pl-k">pub</span> <span class="pl-k">fn</span> <span class="pl-en">new</span>(sid<span class="pl-k">:</span> <span class="pl-k">i32</span><span class="pl-k">,</span> name<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">str</span>) <span class="pl-k">-&gt;</span> <span class="pl-k">Spartan</span> {
        <span class="pl-k">Spartan</span> {
            sid<span class="pl-k">:</span> sid<span class="pl-k">,</span>
            name<span class="pl-k">:</span> name<span class="pl-k">,</span>
        }
    }
}

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> (foo <span class="pl-k">,</span> bar) <span class="pl-k">=</span> (<span class="pl-k">Spartan</span><span class="pl-k">::</span><span class="pl-c1">new</span>(<span class="pl-c1">117</span><span class="pl-k">,</span> <span class="pl-s">"John"</span>)<span class="pl-k">,</span> <span class="pl-k">Spartan</span><span class="pl-k">::</span><span class="pl-c1">new</span>(<span class="pl-c1">062</span><span class="pl-k">,</span> <span class="pl-s">"Jorge"</span>))<span class="pl-k">;</span>

    <span class="pl-k">if</span> foo <span class="pl-k">==</span> bar { 
        println<span class="pl-k">!</span>(<span class="pl-s">"foo equals bar"</span>)<span class="pl-k">;</span> 
    } <span class="pl-k">else</span> { 
        println<span class="pl-k">!</span>(<span class="pl-s">"foo not equals bar"</span>)<span class="pl-k">;</span> 
    }
}</pre></div>

<h3>
<a id="je-narrive-pas-à-utiliser-les-macros-importées-par-ma-bibliothèque--pourquoi-" class="anchor" href="#je-narrive-pas-%C3%A0-utiliser-les-macros-import%C3%A9es-par-ma-biblioth%C3%A8que--pourquoi-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Je n'arrive pas à utiliser les macros importées par ma bibliothèque ! Pourquoi ?</h3>

<p>Il se pourrait que vous ayez omis d'utiliser une annotation : <code>#[macro_use]</code></p>

<p>Cette dernière permet d'exporter toutes les macros qui doivent être publiques pour être utilisées à l'exterieur de la bibliothèque.</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-c">#[macro_use]</span>
<span class="pl-k">extern</span> <span class="pl-k">crate</span> votre_lib<span class="pl-k">;</span>

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    votre_macro<span class="pl-k">!</span>()<span class="pl-k">;</span>
}</pre></div>

<p>Si vous ne parvenez toujours pas à les utiliser, il est possible que vous ayez omis l'annotation <code>#[macro_export]</code> dans les modules comportant vos macros.</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-c">// dans le fichier lib.rs</span>
<span class="pl-c">#[macro_use]</span> <span class="pl-c">// bien préciser que ce module utilise des macros</span>
<span class="pl-k">pub</span> <span class="pl-k">mod</span> votre_conteneur {
    <span class="pl-c">#[macro_export]</span>
    <span class="pl-k">macro_rules!</span> <span class="pl-en">foo</span>
    {
        () <span class="pl-k">=&gt;</span> ()<span class="pl-k">;</span>
    }
    <span class="pl-c">#[macro_export]</span>
    <span class="pl-k">macro_rules!</span> <span class="pl-en">bar</span>
    {
        () <span class="pl-k">=&gt;</span> ()<span class="pl-k">;</span>
    }
    <span class="pl-c">#[macro_export]</span>
    <span class="pl-k">macro_rules!</span> <span class="pl-en">baz</span>
    {
        () <span class="pl-k">=&gt;</span> ()<span class="pl-k">;</span>
    }
}</pre></div>

<p>Si votre problème persiste, je vous invite à vous rendre sur les forums figurant dans la rubrique programmation pour obtenir de l'aide. Présentez clairement l'erreur que le compilateur vous renvoi dans votre post.</p>

<h3>
<a id="a-quoi-servent-les-mot-clés-if-let-" class="anchor" href="#a-quoi-servent-les-mot-cl%C3%A9s-if-let-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi servent les mot-clés if let ?</h3>

<p>La combinaison des deux mot-clés permet d'assigner, de manière concise, du contenu à une variable.</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo <span class="pl-k">:</span> <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">Some</span>(<span class="pl-s">"Hello world!"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>())<span class="pl-k">;</span>
    <span class="pl-k">let</span> <span class="pl-k">mut</span> bar <span class="pl-k">:</span> <span class="pl-k">bool</span> <span class="pl-k">=</span> <span class="pl-c1">false</span><span class="pl-k">;</span>

    <span class="pl-k">if</span> <span class="pl-k">let</span> <span class="pl-k">Some</span>(content) <span class="pl-k">=</span> foo { <span class="pl-c">// si la variable foo contient quelque chose...</span>
        bar <span class="pl-k">=</span> <span class="pl-c1">true</span><span class="pl-k">;</span>
    } <span class="pl-k">else</span> {
        println<span class="pl-k">!</span>(<span class="pl-s">"foo's content is None"</span>)<span class="pl-k">;</span>
    }
}</pre></div>

<p>C'est un moyen simple et efficace d'assigner du contenu sans passer par le pattern matching.</p>

<h3>
<a id="a-quoi-servent-les-mot-clés-while-let-" class="anchor" href="#a-quoi-servent-les-mot-cl%C3%A9s-while-let-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi servent les mot-clés while let ?</h3>

<p>La combinaison des deux mot-clés permet d'effectuer des tests de manière concise et ainsi nous éviter de passer par le pattern matching lorsque ça n'est pas nécessaire. (<code>while let</code> peuvent s'avérer très utiles lorsqu'il faut tester à chaque itération si le fichier contient toujours quelque chose)</p>

<p><strong>[Exemple de la documentation officielle]</strong></p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">let</span> <span class="pl-k">mut</span> v <span class="pl-k">=</span> vec<span class="pl-k">!</span>[<span class="pl-c1">1</span><span class="pl-k">,</span> <span class="pl-c1">3</span><span class="pl-k">,</span> <span class="pl-c1">5</span><span class="pl-k">,</span> <span class="pl-c1">7</span><span class="pl-k">,</span> <span class="pl-c1">11</span>]<span class="pl-k">;</span>

<span class="pl-k">while</span> <span class="pl-k">let</span> <span class="pl-k">Some</span>(x) <span class="pl-k">=</span> v<span class="pl-k">.</span><span class="pl-c1">pop</span>() {
    println<span class="pl-k">!</span>(<span class="pl-s">"{}"</span><span class="pl-k">,</span> x)<span class="pl-k">;</span>
}</pre></div>

<h2>
<a id="mécaniques-et-philosophies" class="anchor" href="#m%C3%A9caniques-et-philosophies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Mécaniques et philosophies</h2>

<h3>
<a id="gestion-de-la-mémoire" class="anchor" href="#gestion-de-la-m%C3%A9moire" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Gestion de la mémoire</h3>

<h4>
<a id="le-développeur-doit-il-gérer-la-mémoire-seul-" class="anchor" href="#le-d%C3%A9veloppeur-doit-il-g%C3%A9rer-la-m%C3%A9moire-seul-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Le développeur doit-il gérer la mémoire seul ?</h4>

<p>Cette FAQ dispose de trois Q/R abordant trois concepts distincts (mais se complétant) gravitant autour de la gestion de la mémoire avec le langage Rust.</p>

<p>Par souci de concision, les Q/R ci-dessous ne retiennent que l'essentiel de chaque concepts :</p>

<ol>
<li> <a href="#quest-ce-que-lownership">Qu'est-ce que « l'ownership » ?</a> </li>
<li> <a href="#quest-ce-que-le-concept-de-borrowing">Qu'est-ce que le concept de « borrowing » ?</a> </li>
<li> <a href="#quest-ce-que-le-concept-de-lifetime">Qu'est-ce que le concept de « lifetime » ?</a> </li>
</ol>

<h4>
<a id="quest-ce-que--lownership--" class="anchor" href="#quest-ce-que--lownership--" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Qu'est-ce que « l'ownership » ?</h4>

<p>Si l'on fait abstraction du contexte dans lequel est employé ce terme (en l'occurrence, la programmation), nous pourrions le traduire de cette façon : « propriété », « possession ».</p>

<p>Nous verrons un peu plus bas que le fonctionnement de ce mécanisme n'est pas si étranger au sens littéral du terme.</p>

<p><strong>Introduction</strong></p>

<p>Rust est muni d'un système « d'appartenance » qui permet d'écarter les conflits les plus communs lorsqu'une ressource est utilisée à plusieurs endroits.</p>

<p>Bien que ce dernier soit très pratique, il demande d'avoir une certaine rigueur quant à la déclaration de nos ressources, sans quoi vous risqueriez de vous attirer les foudres du compilateur.</p>

<p>Pour cela, voici un exemple d'erreur typique lorsque l'on débute sans réellement connaître les tâches effectuées par le « ramasse-miette » :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-c1">from</span>(<span class="pl-s">"Hello world!"</span>)<span class="pl-k">;</span>
    <span class="pl-k">let</span> bar<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> foo<span class="pl-k">;</span>
    <span class="pl-k">let</span> baz<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> foo<span class="pl-k">;</span> <span class="pl-c">//erreur la ressource a été « déplacée »</span>
}</pre></div>

<p>Renvoyant une erreur de ce style :</p>

<div class="highlight highlight-source-rust"><pre>error<span class="pl-k">:</span> <span class="pl-k">use</span> of moved value<span class="pl-k">:</span> `foo`</pre></div>

<p>C'est un exemple simple, mais qui (dans nos débuts) peut être une véritable plaie : on ne comprend pas d'où vient l'erreur - tout est syntaxiquement correct, mais le compilateur n'a pas l'air satisfait.</p>

<p>C'est simple :</p>

<p>La variable foo étant un pointeur contenant l'adresse mémoire d'un objet String, il est courant de dire qu'il possède « l'ownership », il est le seul à pouvoir utiliser cette ressource.</p>

<p>C'est en copiant les informations relatives à l'objet String (en « déplacant » ces informations dans une nouvelle variable, donc) que le <em>garbage</em> <em>collector</em> va faire son travail : détruire le pointeur <em>foo</em> pour attribuer « l'ownership » au nouveau pointeur de la ressource : <em>bar</em>.</p>

<p>C'est lorsque la variable <em>baz</em> essaie de copier les informations de <em>foo</em> que l'erreur survient : <em>foo</em> a déjà été détruit par le <em>garbage</em> <em>collector</em>.</p>

<p>Pour remédier au problème, il aurait simplement suffit de "copier" <em>bar</em> de cette manière :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-s">"Hello world!"</span><span class="pl-k">.</span><span class="pl-c1">to_owned</span>()<span class="pl-k">;</span>
    <span class="pl-k">let</span> bar<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> foo<span class="pl-k">;</span>
    <span class="pl-k">let</span> baz<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-k">&amp;</span>bar<span class="pl-k">;</span> <span class="pl-c">// on récupère une référence</span>
}</pre></div>

<p>Tout est en règle, le compilateur ne râle plus, et si vous souhaitez afficher votre chaîne de caractères sur la sortie standard, rien ne vous en empêche !</p>

<p>Vous pouvez très bien écrire ceci :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo <span class="pl-k">=</span> <span class="pl-c1">42</span><span class="pl-k">;</span>
    <span class="pl-k">let</span> bar <span class="pl-k">=</span> foo<span class="pl-k">;</span>
    <span class="pl-k">let</span> baz <span class="pl-k">=</span> foo<span class="pl-k">;</span>
}</pre></div>

<p>Car les types primitifs tels que les <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>u8</code>, ... implémentent le trait <code>Copy</code>.</p>

<p><strong>Quid des fonctions ?</strong></p>

<p>Les fonctions obéissent aux mêmes règles que les pointeurs :</p>

<p>Lorsqu'une ressource est passée en paramètre par copie, la fonction « possède » la ressource, même lorsqu'elle a terminé de s'exécuter.</p>

<p>Exemple :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">my_func</span>(my_string<span class="pl-k">:</span> <span class="pl-k">String</span>) {
    <span class="pl-k">for</span> letter <span class="pl-k">in</span> my_string<span class="pl-k">.</span><span class="pl-c1">chars</span>() {
        println<span class="pl-k">!</span>(<span class="pl-s">"{}"</span><span class="pl-k">,</span> <span class="pl-k">&amp;</span>letter)<span class="pl-k">;</span>
    }
}

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-c1">from</span>(<span class="pl-s">"The cake is a lie!"</span>)<span class="pl-k">;</span>

    <span class="pl-c1">my_func</span>(foo)<span class="pl-k">;</span>
    <span class="pl-k">let</span> chars <span class="pl-k">=</span> foo<span class="pl-k">.</span><span class="pl-c1">chars</span>()<span class="pl-k">;</span> <span class="pl-c">//error</span>
}</pre></div>

<p>Vous remarquerez donc ici que le pointeur <strong>foo</strong> a été détruit, la copie de la chaîne de caractères appartient désormais à la fonction.</p>

<p>Voir aussi : <a href="#quest-ce-que-le-concept-de-borrowing">Qu'est-ce que le concept de « borrowing » ?</a></p>

<h4>
<a id="quest-ce-que-le-concept-de--borrowing--" class="anchor" href="#quest-ce-que-le-concept-de--borrowing--" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Qu'est-ce que le concept de « borrowing » ?</h4>

<p>Il est courant de devoir partager une ressource entre plusieurs pointeurs pour effectuer diverses tâches.</p>

<p>Toutefois, plus une ressource est sollicitée, plus il y a de chance qu'elle soit <em>désynchronisée/invalidée</em> à un moment ou un autre. (c'est encore plus fréquent lorsque cette dernière est sollicitée par plusieurs fils d'exécution)</p>

<p>Rust remédie à ce problème grâce au « borrow checking », un système d'emprunts créant en quelque sorte des <em>mutex</em> chargés de limiter l'accès à une ressource et ainsi éviter les risques d'écritures simultanées.</p>

<p>Le borrow checker fera respecter ces trois règles (que vous pouvez retrouver dans la documentation officielle) :</p>

<ol>
<li>Une (ou plusieurs) variable peut emprunter la ressource en lecture. (référence immuable)</li>
<li>Un, et <strong>seulement un</strong>, pointeur peut disposer d'un accès en écriture sur la ressource.</li>
<li>Vous ne pouvez pas accéder à la ressource en lecture et en écriture en même temps, exemple :</li>
</ol>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>()  {
    <span class="pl-k">let</span> <span class="pl-k">mut</span> foo <span class="pl-k">=</span> <span class="pl-c1">117</span><span class="pl-k">;</span>
    <span class="pl-k">let</span> bar <span class="pl-k">=</span> <span class="pl-k">&amp;</span><span class="pl-k">mut</span> foo<span class="pl-k">;</span>
    <span class="pl-k">let</span> baz <span class="pl-k">=</span> <span class="pl-k">&amp;</span>foo<span class="pl-k">;</span> <span class="pl-c">// erreur</span>
}</pre></div>

<p>Ou :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> <span class="pl-k">mut</span> foo <span class="pl-k">=</span> <span class="pl-c1">117</span><span class="pl-k">;</span>
    <span class="pl-k">let</span> bar <span class="pl-k">=</span> <span class="pl-k">&amp;</span><span class="pl-k">mut</span> foo<span class="pl-k">;</span>
    <span class="pl-k">let</span> baz <span class="pl-k">=</span> <span class="pl-k">&amp;</span><span class="pl-k">mut</span> foo<span class="pl-k">;</span> <span class="pl-c">//erreur</span>
}</pre></div>

<h4>
<a id="quest-ce-que-le-concept-de--lifetime--" class="anchor" href="#quest-ce-que-le-concept-de--lifetime--" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Qu'est-ce que le concept de « lifetime » ?</h4>

<p><strong>Introduction</strong></p>

<p>Comme tout langages (sauf exception que nous pourrions ignorer), Rust dispose d'un système de durée de vie.</p>

<p>Toutefois, il fait preuve d'une grande rigourosité quant à la destruction des ressources dynamiques et à « l'isolement » des ressources statiques après utilisation.</p>

<p>Voici un exemple :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> <span class="pl-k">mut</span> foo<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-s">"Hello world!"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">;</span> <span class="pl-c">// Le scope A commence ici</span>
    <span class="pl-k">let</span> bar<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-s">"Goodbye, friend !"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">;</span> <span class="pl-c">// Le scope B commence ici</span>
    foo <span class="pl-k">=</span> bar<span class="pl-k">;</span> <span class="pl-c">// bar détruit, le scope B s'arrête là</span>
    println<span class="pl-k">!</span>(<span class="pl-s">"{}"</span><span class="pl-k">,</span> <span class="pl-k">&amp;</span>bar)<span class="pl-k">;</span>
} <span class="pl-c">// Le Scope A s'arrête ici</span></pre></div>

<p>On remarque à la suite de cet exemple que le concept de « scope » (contexte) n'est pas à l'échelle d'une fonction, mais bien des variables, incitant le développeur à déclarer et initialiser sa ressource uniquement lorsqu'il en a besoin.</p>

<p>*<em>Quid des références ? *</em></p>

<p>Le concept de durée de vie dédiée aux références peut parfois dérouter, surtout lorsqu'il faut expliciter certains tags (représentants des durées de vie) au compilateur lorsqu'il nous l'impose et que l'on ne comprend pas bien pourquoi.</p>

<p>Les références n'échappent pas à la règle, elles aussi ont des durées vie bien déterminées ; En règle générale, il n'est pas utile (voire interdit) au développeur d'expliciter les tags qui permettent au compilateur de « suivre » chaque référence durant son utilisation.</p>

<p>Cependant, lorsque l'une d'elles est passée en paramètre à une fonction, il peut parfois être nécessaire de tagger celles qui survivront au moins à l'exécution de la fonction. (ne serait-ce que par souci de clareté)</p>

<p>Voici un exemple qui pourrait vous épauler : (attention à bien lire les commentaires)</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">foo</span>(phrase<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">str</span>) { <span class="pl-c">//aucune référence ne survit, donc pas la peine de l'annoter</span>
    println<span class="pl-k">!</span>(<span class="pl-s">"{}"</span><span class="pl-k">,</span> <span class="pl-k">&amp;</span>phrase)<span class="pl-k">;</span>
}

<span class="pl-k">fn</span> <span class="pl-en">bar</span><span class="pl-k">&lt;</span><span class="pl-k">'a</span><span class="pl-k">&gt;</span>(phrase<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">'a</span> <span class="pl-k">mut</span> <span class="pl-k">String</span><span class="pl-k">,</span> word<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">str</span>) <span class="pl-k">-&gt;</span> <span class="pl-k">&amp;</span><span class="pl-k">'a</span> <span class="pl-k">String</span> { <span class="pl-c">// une référence va survivre il faut maintenant savoir laquelle</span>
    phrase<span class="pl-k">.</span><span class="pl-c1">push_str</span>(word)<span class="pl-k">;</span>
    phrase
} <span class="pl-c">// La référence qui survivra sera donc « phrase », elle dispose donc de la durée de vie 'a.</span>

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> <span class="pl-k">mut</span> baz<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-s">"Hello "</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">;</span>
    <span class="pl-k">let</span> word<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">str</span>   <span class="pl-k">=</span> <span class="pl-s">"world!"</span><span class="pl-k">;</span>
    <span class="pl-k">let</span> bazz <span class="pl-k">=</span> <span class="pl-c1">bar</span>(<span class="pl-k">&amp;</span><span class="pl-k">mut</span> baz<span class="pl-k">,</span> word)<span class="pl-k">;</span> <span class="pl-c">//ce que contient la varialbe bazz ne peut être accédé qu'en lecture</span>
    println<span class="pl-k">!</span>(<span class="pl-s">"{}"</span><span class="pl-k">,</span> <span class="pl-k">&amp;</span>bazz)<span class="pl-k">;</span> <span class="pl-c">//nous affichons nos caractères sur la sortie standard</span>
}</pre></div>

<p>En revanche, ce n'est pas un cas commun, nous vous invitons donc à vous tourner vers la documentation officielle ou à expérimenter par vous-même.</p>

<p><strong>Que faut-il retenir ?</strong></p>

<p>Pour faire simple, il faut retenir que :</p>

<ul>
<li>Chaque variable créé un nouveau scope lors de sa déclaration ;</li>
<li>Toutes variables retrouvées dans le scope d'une autre verra sa durée de vie plus courte que cette dernière ;</li>
<li>A propos des références passées en paramètres, seules les références survivant au moins à la fin de l'exécution de la fonction devraient être annotées.</li>
</ul>

<p>Voir aussi :</p>

<p><a href="https://doc.rust-lang.org/nomicon/lifetimes.html">Le Rustonomicon</a></p>

<p><a href="https://doc.rust-lang.org/book/lifetimes.html">La section dédiée du livre</a></p>

<h4>
<a id="comment-étendre-un-trait-sur-un-autre-trait-" class="anchor" href="#comment-%C3%A9tendre-un-trait-sur-un-autre-trait-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment étendre un trait sur un autre trait ?</h4>

<h2>
<a id="outils-de-build" class="anchor" href="#outils-de-build" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Outils de build</h2>

<h3>
<a id="comment-créer-un-projet-avec-cargo-" class="anchor" href="#comment-cr%C3%A9er-un-projet-avec-cargo-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment créer un projet avec Cargo ?</h3>

<p>Pour créer un nouveau projet avec Cargo, vérifiez d'abord qu'il est <em>installé</em> sur votre machine :</p>

<p><code>$ cargo -V</code></p>

<p>Puis :</p>

<p><code>$ cargo new nom_de_votre_repertoire</code></p>

<p>Vous devriez voir se générer un dossier avec le nom assigné dans lequel se trouvera un répertoire nommé src et un manifest nommé <em>Cargo.toml</em>.</p>

<h3>
<a id="quel-type-de-projet-puis-je-créer-avec-cargo-" class="anchor" href="#quel-type-de-projet-puis-je-cr%C3%A9er-avec-cargo-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quel type de projet puis-je créer avec Cargo ?</h3>

<p>Lorsque vous lancez la commande de génération (telle qu'elle), votre projet est généré en mode « bibliothèque », et n'est donc pas destiné à être directement exécuté.</p>

<p>Si vous souhaitez générer un projet en mode « exécutable », il suffit de le préciser dans la commande :</p>

<p><code>$ cargo new folder_name  --bin</code></p>

<p>Par défaut, le nom du répertoire racine sera également le nom de votre bibliothèque si elle devait être identifiée par d'autres utilisateurs dans le but de la télécharger. Si vous souhaitez lui attribuer un autre nom, vous pouvez également le spécifier dans la commande :</p>

<p><code>$ cargo new folder_name --name another_name  --bin</code></p>

<p>Le manifest sera modifié en conséquence.</p>

<h3>
<a id="comment-compiler-son-projet-" class="anchor" href="#comment-compiler-son-projet-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment compiler son projet ?</h3>

<p>Pour compiler votre projet, vous devez vous trouver à la racine de ce dernier.</p>

<p>Une fois que c'est fait, il vous suffit de lancer la commande suivante :</p>

<p><code>$ cargo build</code></p>

<h3>
<a id="peut-on-générer-de-la-documentation-avec-cargo-" class="anchor" href="#peut-on-g%C3%A9n%C3%A9rer-de-la-documentation-avec-cargo-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Peut-on générer de la documentation avec Cargo ?</h3>

<p>Bien sûr !</p>

<p>Il suffit de lancer la commande $ cargo doc à la racine de votre projet.</p>

<p>La documentation se trouvera dans le dossier <code>./target/doc/…</code></p>

<p><strong>Où est l'index de mon site ?</strong></p>

<p>Il se trouve dans le répertoire portant le nom de votre projet.</p>

<h3>
<a id="où-trouver-de-nouvelles-bibliothèques-" class="anchor" href="#o%C3%B9-trouver-de-nouvelles-biblioth%C3%A8ques-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Où trouver de nouvelles bibliothèques ?</h3>

<p>Vous pouvez trouver d'autres bibliothèques sur le <a href="https://crates.io/crates">site officiel</a> de Cargo.</p>

<p>Voir aussi : <a href="#comment-installer-de-nouvelles-biblioth%C3%A8ques">Comment installer de nouvelles bibliothèques ?</a></p>

<h3>
<a id="comment-installer-de-nouvelles-bibliothèques-" class="anchor" href="#comment-installer-de-nouvelles-biblioth%C3%A8ques-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment installer de nouvelles bibliothèques ?</h3>

<p>Il y a deux manières de faire :</p>

<ol>
<li>Les télécharger à partir de <a href="https://crates.io/crates">crate.io</a> ;</li>
<li>Les télécharger directement à partir de leur dépôt github.</li>
</ol>

<p>C'est selon vos préférences. (et surtout selon la disponibilité de la ressource)</p>

<p>Donc pour la première façon, rien de plus simple :</p>

<ul>
<li>Vous cherchez la bibliothèque que vous désirez sur le site ;</li>
<li>Vous renseignez son nom dans votre manifest ;</li>
<li>Compilez ;</li>
<li>C'est prêt !</li>
</ul>

<p>Pour la seconde :</p>

<ul>
<li>Cherchez le dépôt github de la bibliothèque désirée ;</li>
<li>Notez le nom que porte cette bibliothèque dans son manifest ;</li>
<li>Puis ajoutez cette ligne dans vos dépendences : <code>lib_name = {git = "url du dépôt" }</code> ;</li>
<li>Compilez ;</li>
<li>C'est prêt !</li>
</ul>

<h3>
<a id="comment-publier-sa-bibliothèque-faite-maison-" class="anchor" href="#comment-publier-sa-biblioth%C3%A8que-faite-maison-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment publier sa bibliothèque faite-maison ?</h3>

<p>Les procédures étant très bien expliquées sur le site de <a href="http://crates.io/">crates.io</a>, nous vous invitons à vous rendre dans la <a href="http://doc.crates.io/crates-io.html">section dédiée</a>.</p>

<p>Si vous souhaitez malgré tout lire les procédures sur la FAQ, en voici une traduction :</p>

<p>Une fois que vous avez une bibliothèque que vous souhaiteriez partager avec le reste du monde, il est temps de la publier sur <a href="http://crates.io/">crates.io</a> !</p>

<p>La publication d'un paquet est effective lorsqu'il est uploadé pour être hébergé par <a href="http://crates.io/">crates.io</a>.</p>

<p><strong>Attention</strong>:</p>

<blockquote>
<p>Réfléchissez avant de publier votre paquet, car sa publication est permanente.
La version publiée ne pourra jamais être écrasée par une autre, et le code ne pourra être supprimé.
En revanche, le nombre de versions publiées n'est pas limité.</p>
</blockquote>

<p><strong>Avant votre première publication</strong></p>

<p>Premièrement, vous allez avoir besoin d'un compte sur crates.io pour recevoir un « token » (jeton) provenant de l'API. Pour faire ceci, visitez la page d'accueil et enregistrez-vous via votre compte Github. Ensuite, rendez-vous dans vos options de compte, et lancez la commande $ cargo login suivi de votre token.</p>

<div class="highlight highlight-source-shell"><pre>$ cargo login abcdefghijklmnopqrstuvwxyz012345</pre></div>

<p>Cette commande va informer Cargo que vous détenez un token provenant de l'API du site. (il est enregistré dans le chemin suivant : ~/.cargo/config.)</p>

<p>Ce token doit rester secret et ne devrait être partagé avec personne. Si vous le perdez d'une quelconque manière, régénérez-le immédiatement.</p>

<p><strong>Avant la publication du paquet</strong></p>

<p>Gardez en tête que le nom de chaque paquet est alloué en respectant la règle du « premier arrivé, premier servi ». Une fois que vous avez choisi un nom, il ne pourra plus être utilisé pour un autre paquet.</p>

<p><strong>Empaqueter le projet</strong></p>

<p>La prochaine étape consiste à empaqueter votre projet de manière à être intelligible pour crates.io. Pour remédier à cela, nous allons utiliser la commande cargo package. Votre projet sera donc empaqueter sous la format *.crate et se trouvera dans le répertoire target/package/.</p>

<div class="highlight highlight-source-shell"><pre>$ cargo package</pre></div>

<p>En plus de cela, la commande package est capable de vérifier l'intégrité de votre projet en dépaquetant votre *.crate et le recompiler. Si la phase de vérification se passe sans problème, rien ne devrait être affiché dans votre terminal.</p>

<p>Toutefois, si vous souhaitez désactiver cette vérification avant l'envoi, il vous suffit d'ajouter le flag --no-verify.</p>

<p>Cargo va ignorer automatiquement tous les fichiers ignorés par votre système de versionning, mais si vous voulez spécifier un type de fichiers en particulier, vous pouvez utiliser le mot-clé exclude dans votre manifest :</p>

<p>[Exemple tiré de la <a href="http://doc.crates.io/crates-io.html">documentation officielle</a> de l'outil]</p>

<pre lang="text"><code>[package]
# ...
exclude = [
    "public/assets/*",
    "videos/*",
]
</code></pre>

<p>La syntaxe de chaque élément dans ce tableau est ce que glob accepte. Si vous souhaitez créer une whitelist au lieu d'une blacklist, vous pouvez utiliser le mot-clé include.</p>

<p>[Exemple tiré de la <a href="http://doc.crates.io/crates-io.html">documentation officielle</a> de l'outil]</p>

<pre lang="text"><code>[package]
# ...
include = [
    "**/*.rs",
    "Cargo.toml",
]
</code></pre>

<p>Maintenant que nous avons un fichier *.crate prêt à y aller, il peut être uploadé sur crates.io grâce à la commande cargo publish. C'est tout, vous venez de publier votre premier paquet !</p>

<div class="highlight highlight-source-shell"><pre>$ cargo publish</pre></div>

<p>Si vous venez à oublier de lancer la commande <code>cargo package</code>, <code>cargo publish</code> le fera à votre place et vérifiera l'intégrité de votre projet avant de lancer l'étape de publication.</p>

<blockquote>
<p>Il se pourrait que la commande publish vous refuse votre première publication. Pas de panique, ce n'est pas très grave.
Votre paquet, pour être différencié des autres, doit compter un certain nombre de métadonnées pour renseigner vos futurs utilisateurs sur les tenants et aboutissants de votre projet, comme la licence par exemple.
Pour ceci, vous pouvez vous rendre <a href="http://doc.crates.io/manifest.html#package-metadata">ici</a>, et ainsi visionner un exemple simple des métadonnées à renseigner.
Relancez votre procédure <code>cargo publish</code>, vous ne devriez plus avoir de problème.</p>
</blockquote>

<p>Un problème pour accéder à l'exemple ? En voici un autre :</p>

<div class="highlight highlight-source-toml"><pre>[<span class="pl-en">package</span>]
<span class="pl-smi">name</span> = <span class="pl-s"><span class="pl-pds">"</span>verbose_bird<span class="pl-pds">"</span></span>
<span class="pl-smi">version</span> = <span class="pl-s"><span class="pl-pds">"</span>0.3.2<span class="pl-pds">"</span></span>
<span class="pl-smi">authors</span> = [<span class="pl-s"><span class="pl-pds">"</span>Songbird0 &lt;chaacygg@gmail.com&gt;<span class="pl-pds">"</span></span>]
<span class="pl-smi">description</span> = <span class="pl-s"><span class="pl-pds">"</span>An awesome homemade loggers pack.<span class="pl-pds">"</span></span>
<span class="pl-smi">documentation</span> = <span class="pl-s"><span class="pl-pds">"</span>https://github.com/Songbird0/Verbose_Bird/blob/master/src/README.md<span class="pl-pds">"</span></span>
<span class="pl-smi">homepage</span> = <span class="pl-s"><span class="pl-pds">"</span>https://github.com/Songbird0/Verbose_Bird<span class="pl-pds">"</span></span>
<span class="pl-smi">repository</span> = <span class="pl-s"><span class="pl-pds">"</span>https://github.com/Songbird0/Verbose_Bird<span class="pl-pds">"</span></span>

<span class="pl-smi">readme</span> = <span class="pl-s"><span class="pl-pds">"</span>README.md<span class="pl-pds">"</span></span>

<span class="pl-smi">keywords</span> = [<span class="pl-s"><span class="pl-pds">"</span>Rust<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>log<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>loggers<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>pack<span class="pl-pds">"</span></span>]

<span class="pl-smi">license</span> = <span class="pl-s"><span class="pl-pds">"</span>GPL-3.0<span class="pl-pds">"</span></span>

<span class="pl-smi">license-file</span> = <span class="pl-s"><span class="pl-pds">"</span>LICENSE.md<span class="pl-pds">"</span></span>

[<span class="pl-en">dependencies</span>]</pre></div>

<p><strong>Attention</strong>:</p>

<blockquote>
<p>Il se peut que vous rencontriez également des problèmes avec l'entrée « license = ... » vous informant que le nom de licence entré n'est pas valide.
Pour régler le souci rendez-vous sur <a href="https://opensource.org/licenses/alphabetical">opensource.org</a> et visionner les noms raccourcis entre parenthèses de chaque licence.</p>
</blockquote>

<h3>
<a id="comment-lancer-des-tests-avec-cargo-" class="anchor" href="#comment-lancer-des-tests-avec-cargo-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment lancer des tests avec Cargo ?</h3>

<p>Pour lancer un test avec cargo, il vous faudra utiliser l'attribut <code>#[test]</code> et, évidemment, la commande <code>$ cargo test</code>.</p>

<p>Voici un exemple simple de tests :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-c">#[cfg(test)]</span>
<span class="pl-k">mod</span> oo_tests {
    <span class="pl-k">struct</span> <span class="pl-k">Alice</span><span class="pl-k">;</span>
    <span class="pl-k">use</span> loggers_pack<span class="pl-k">::</span>oop<span class="pl-k">::</span><span class="pl-k">Logger</span><span class="pl-k">;</span>
    <span class="pl-k">impl</span> <span class="pl-k">Logger</span> <span class="pl-k">for</span> <span class="pl-k">Alice</span>{<span class="pl-c">/*...*/</span>}

    <span class="pl-c">#[test]</span>
    <span class="pl-k">fn</span> <span class="pl-en">pack_logger_oop_info</span>() {
        <span class="pl-k">Alice</span><span class="pl-k">::</span><span class="pl-c1">info</span>(<span class="pl-s">"@Alice"</span><span class="pl-k">,</span> <span class="pl-s">"Hello, I'm Alice "</span><span class="pl-k">,</span> <span class="pl-s">"Peterson !"</span>)<span class="pl-k">;</span>
    }

    <span class="pl-c">#[test]</span>
    <span class="pl-k">fn</span> <span class="pl-en">pack_logger_oop_wan</span>() {
        <span class="pl-k">Alice</span><span class="pl-k">::</span><span class="pl-c1">warn</span>(<span class="pl-s">"@Alice"</span><span class="pl-k">,</span> <span class="pl-s">"Hello, I'm Alice "</span><span class="pl-k">,</span> <span class="pl-s">"Peterson !"</span>)<span class="pl-k">;</span>
    }

    <span class="pl-c">#[test]</span>
    <span class="pl-k">fn</span> <span class="pl-en">pack_logger_oop_error</span>() {
        <span class="pl-k">Alice</span><span class="pl-k">::</span><span class="pl-c1">error</span>(<span class="pl-s">"@Alice"</span><span class="pl-k">,</span> <span class="pl-s">"Hello, I'm Alice "</span><span class="pl-k">,</span> <span class="pl-s">"Peterson !"</span>)<span class="pl-k">;</span>
    }

    <span class="pl-c">#[test]</span>
    <span class="pl-k">fn</span> <span class="pl-en">pack_logger_oop_success</span>() {
        <span class="pl-k">Alice</span><span class="pl-k">::</span><span class="pl-c1">success</span>(<span class="pl-s">"@Alice"</span><span class="pl-k">,</span> <span class="pl-s">"Hello, I'm Alice "</span><span class="pl-k">,</span> <span class="pl-s">"Peterson !"</span>)<span class="pl-k">;</span>
    }
}</pre></div>

<p>Chaque fonction annotée par l'attribut <code>#[test]</code> sera compilée durant la phase de test.</p>

<p><strong>Attention</strong>:</p>

<blockquote>
<p>La version <strong>1.9.0</strong> de Rust comporte un bogue au niveau des tests. Dans cette version, toutes les fonctions annotées <code>#[test]</code> doivent être encapsulées dans un module. Ce n'est bien entendu plus le cas en <strong>1.12.1</strong>.
Si vous rencontrez ce problème, nous vous conseillons de mettre à jour votre compilateur.</p>
</blockquote>

<h3>
<a id="comment-mettre-à-jour-mes-bibliothèques-" class="anchor" href="#comment-mettre-%C3%A0-jour-mes-biblioth%C3%A8ques-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment mettre à jour mes bibliothèques ?</h3>

<p>Pour mettre à jour vos dépendences, il vous suffit d'utiliser la commande : <code>$ cargo update</code>.</p>

<p>Vous pouvez également préciser quelle bibliothèque mettre à jour séparément en utilisation l'option <code>$ cargo update --precise nom_dep</code></p>

<h3>
<a id="comment-créer-ses-benchmarks-avec-cargo-" class="anchor" href="#comment-cr%C3%A9er-ses-benchmarks-avec-cargo-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment créer ses benchmarks avec Cargo ?</h3>

<p>Pour créer nos benchmark, donc, nous allons utiliser le paquet <a href="https://crates.io/crates/bencher">bencher</a>.</p>

<p>Ce module était premièrement connu sous le nom test puis bencher qui sera porté en tant que dépendance externe pour éviter les effets de bord dans les versions stables du langage.</p>

<div class="highlight highlight-source-toml"><pre>[<span class="pl-en">package</span>]
<span class="pl-smi">name</span> = <span class="pl-s"><span class="pl-pds">"</span>awesome_tests<span class="pl-pds">"</span></span>
<span class="pl-smi">version</span> = <span class="pl-s"><span class="pl-pds">"</span>0.1.0<span class="pl-pds">"</span></span>
<span class="pl-smi">authors</span> = [<span class="pl-s"><span class="pl-pds">"</span>Songbird0 &lt;chaacygg@gmail.com&gt;<span class="pl-pds">"</span></span>]

[<span class="pl-en">dependencies</span>]

<span class="pl-smi">bencher</span> = <span class="pl-s"><span class="pl-pds">"</span>0.1.1<span class="pl-pds">"</span></span>

[[<span class="pl-en">bench</span>]]
<span class="pl-smi">name</span> = <span class="pl-s"><span class="pl-pds">"</span>my_bench<span class="pl-pds">"</span></span>
<span class="pl-smi">harness</span> = <span class="pl-c1">false</span></pre></div>

<p>Voici un exemple basique de benchmark pour une fonction qui recherche le mot le plus court d'une phrase :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-c">#[macro_use]</span>
<span class="pl-k">extern</span> <span class="pl-k">crate</span> bencher<span class="pl-k">;</span>
<span class="pl-k">use</span> bencher<span class="pl-k">::</span><span class="pl-k">Bencher</span><span class="pl-k">;</span>

<span class="pl-k">fn</span> <span class="pl-en">find_short</span>(s<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">str</span>) <span class="pl-k">-&gt;</span> <span class="pl-k">usize</span> {
    <span class="pl-k">let</span> splitting<span class="pl-k">:</span> <span class="pl-k">Vec</span><span class="pl-k">&lt;&amp;</span><span class="pl-k">str</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> s<span class="pl-k">.</span><span class="pl-c1">split_whitespace</span>()<span class="pl-k">.</span><span class="pl-c1">collect</span>()<span class="pl-k">;</span>
    <span class="pl-k">let</span> <span class="pl-k">mut</span> shortest_len<span class="pl-k">:</span> <span class="pl-k">usize</span> <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">;</span>
    <span class="pl-k">let</span> <span class="pl-k">mut</span> i<span class="pl-k">:</span> <span class="pl-k">usize</span> <span class="pl-k">=</span> <span class="pl-c1">0</span><span class="pl-k">;</span>

    <span class="pl-k">while</span> i <span class="pl-k">&lt;</span> splitting<span class="pl-k">.</span><span class="pl-c1">len</span>() {
        <span class="pl-k">if</span> i <span class="pl-k">==</span> <span class="pl-c1">0</span> {
            shortest_len <span class="pl-k">=</span> splitting[<span class="pl-c1">0</span>]<span class="pl-k">.</span><span class="pl-c1">len</span>()<span class="pl-k">;</span>
        } <span class="pl-k">else</span> {
            <span class="pl-k">if</span> splitting[i]<span class="pl-k">.</span><span class="pl-c1">len</span>() <span class="pl-k">&lt;</span> shortest_len {
                shortest_len <span class="pl-k">=</span> splitting[i]<span class="pl-k">.</span><span class="pl-c1">len</span>()<span class="pl-k">;</span>
            }
        }
        i <span class="pl-k">+=</span> <span class="pl-c1">1</span><span class="pl-k">;</span>
    }
    shortest_len
}

<span class="pl-k">fn</span> <span class="pl-en">bench_find_short</span>(b<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">mut</span> <span class="pl-k">Bencher</span>) {
    b<span class="pl-k">.</span><span class="pl-c1">iter</span>(<span class="pl-k">||</span> <span class="pl-c1">find_short</span>(<span class="pl-s">"Hello darkness my old friend"</span>))<span class="pl-k">;</span>
}

benchmark_group<span class="pl-k">!</span>(my_bench<span class="pl-k">,</span> bench_find_short)<span class="pl-k">;</span>
benchmark_main<span class="pl-k">!</span>(my_bench)<span class="pl-k">;</span></pre></div>

<h3>
<a id="a-quoi-sert-benchmark_group-" class="anchor" href="#a-quoi-sert-benchmark_group-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert benchmark_group! ?</h3>

<p>La macro <code>bencmark_group!</code> sert a créer des « groupes » de fonctions à mesurer lors de l'exécution de la commande <code>cargo bench</code>.</p>

<h3>
<a id="a-quoi-sert-benchmark_main-" class="anchor" href="#a-quoi-sert-benchmark_main-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert benchmark_main! ?</h3>

<p>La macro <code>benchmark_main!</code> permet de créer une fonction main contenant toutes les fonctions à « benmarker ».</p>

<h2>
<a id="gestion-des-erreurs" class="anchor" href="#gestion-des-erreurs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Gestion des erreurs</h2>

<h3>
<a id="comment-seffectue-la-gestion-des-erreurs-avec-rust-" class="anchor" href="#comment-seffectue-la-gestion-des-erreurs-avec-rust-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment s'effectue la gestion des erreurs avec Rust ?</h3>

<p>Tout comme les langages impératifs classiques (e.g. C), Rust ne gère pas les erreurs grâce à un système « d'exceptions » comme nous pourrions retrouver dans des langages plus orientés objets, mais grâce au contenu renvoyé en sortie de fonction.</p>

<p>Plusieurs fonctions (et macros) sont d'ailleurs dédiées à cette gestion (e.g. <code>panic!</code>, <code>unwrap()</code> (et ses dérivés), <code>and_then()</code>) permettant ainsi de rattraper (d'une manière plus ou moins fine) la situation lorsque les conditions imposées par vos soins ne sont pas respectées.</p>

<p>Cette section regroupe donc un certain nombre de Q/R qui pourrait vous aider à mieux cerner ce système de gestion :</p>

<ul>
<li> <a href="#a-quoi-sert-la-macro-panic">A quoi sert la macro panic! ?</a> </li>
<li> <a href="#a-quoi-sert-la-m%C3%A9thode-unwrap">A quoi sert la méthode unwrap ?</a> </li>
<li> <a href="#a-quoi-sert-la-m%C3%A9thode-unwrap_or">A quoi sert la méthode unwrap_or ?</a> </li>
<li> <a href="#a-quoi-sert-la-m%C3%A9thode-unwrap_or_else">A quoi sert la méthode unwrap_or_else ?</a> </li>
<li>
<a href="#a-quoi-sert-la-m%C3%A9thode-map">A quoi sert la méthode map ?</a> <img src="./images/WIP.gif" alt="">
</li>
<li> <a href="#a-quoi-sert-la-m%C3%A9thode-and_then">A quoi sert la méthode and_then ?</a> </li>
<li>
<a href="#a-quoi-sert-la-macro-try">A quoi sert la macro try! ?</a> <img src="./images/WIP.gif" alt="">
</li>
<li> <a href="#comment-utiliser-la-macro-assert">Comment utiliser la macro assert! ?</a> </li>
<li> <a href="#comment-utiliser-la-macro-assert_eq">Comment utiliser la macro assert_eq! ?</a> </li>
<li> <a href="#comment-utiliser-la-macro-debug_assert">Comment utiliser la macro debug_assert! ?</a> </li>
<li>
<a href="#quest-ce-que-l%C3%A9num%C3%A9ration-option">Qu'est-ce que l'énumération Option ?</a> <img src="./images/WIP.gif" alt="">
</li>
<li>
<a href="#comment-utiliser-l%C3%A9num%C3%A9ration-option">Comment utiliser l'énumération Option ?</a> <img src="./images/WIP.gif" alt="">
</li>
<li>
<a href="#quest-ce-que-l%C3%A9num%C3%A9ration-result">Qu'est-ce que l'énumération Result ?</a> <img src="./images/WIP.gif" alt="">
</li>
<li>
<a href="#comment-utiliser-l%C3%A9num%C3%A9ration-result">Comment utiliser l'énumération Result ?</a> <img src="./images/WIP.gif" alt="">
</li>
</ul>

<h3>
<a id="comment-créer-un-type-spécifique-dexceptions-" class="anchor" href="#comment-cr%C3%A9er-un-type-sp%C3%A9cifique-dexceptions-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment créer un type spécifique d'exceptions ?</h3>

<p>Il n'est pas possible de créer de créer une structure censée représenter un type d'erreur, comme nous pourrions le faire en Java ; Rust ne gère pas les potentielles de cette manière.</p>

<p>Voir aussi :</p>

<p><a href="#comment-seffectue-la-gestion-des-erreurs-avec-rust">Comment s'effectue la gestion des erreurs avec Rust ?</a></p>

<h3>
<a id="est-il-possible-de-créer-des-assertions-" class="anchor" href="#est-il-possible-de-cr%C3%A9er-des-assertions-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Est-il possible de créer des assertions ?</h3>

<p>Oui, bien entendu.</p>

<p>Il existe trois assertions différentes en Rust (toutes encapsulées par une macro) :</p>

<ol>
<li>
<a href="https://doc.rust-lang.org/std/macro.assert!.html" title="Ouvrir un nouvel onglet">assert!</a>!;</li>
<li>
<a href="https://doc.rust-lang.org/std/macro.assert_eq!.html" title="Ouvrir un nouvel onglet">assert_eq!</a>!;</li>
<li>
<a href="https://doc.rust-lang.org/std/macro.debug_assert!.html" title="Ouvrir un nouvel onglet">debug_assert!</a>!.</li>
</ol>

<p>Voir aussi :</p>

<ul>
<li> <a href="#comment-utiliser-la-macro-assert">Comment utiliser la macro assert! ?</a> </li>
<li> <a href="#comment-utiliser-la-macro-assert_eq">Comment utiliser la macro assert_eq! ?</a> </li>
<li> <a href="#comment-utiliser-la-macro-debug_assert">Comment utiliser la macro debug_assert! ?</a> </li>
</ul>

<h3>
<a id="a-quoi-sert-la-macro-panic-" class="anchor" href="#a-quoi-sert-la-macro-panic-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert la macro panic! ?</h3>

<p>La macro <code>panic!</code> pourrait être comparée aux exceptions <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/RuntimeException.html" title="Ouvrir un nouvel onglet">RuntimeException</a> en Java qui sont, à coup sûr, des erreurs bloquantes.</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">MyClass</span> 
{
        <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">main</span>(<span class="pl-k">String</span>[] <span class="pl-v">args</span>) 
        {
            <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-smi">RuntimeException</span>(<span class="pl-s"><span class="pl-pds">"</span>Error !<span class="pl-pds">"</span></span>);
            <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>Dead code.<span class="pl-pds">"</span></span>);
        }
}</pre></div>

<p>Elle est donc la macro la plus bas niveau que l'on peut retrouver parmi les macros et/ou fonctions proposées par la bibliothèque standard; Elle ne prend rien en compte mis à part l'arrêt du programme et l'affichage de la trace de la pile.</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    panic<span class="pl-k">!</span>(<span class="pl-s">"Error !"</span>)<span class="pl-k">;</span>
    println<span class="pl-k">!</span>(<span class="pl-s">"Dead code"</span>)<span class="pl-k">;</span>
}</pre></div>

<p>Voir aussi :</p>

<ul>
<li><a href="#a-quoi-sert-la-m%C3%A9thode-unwrap">A quoi sert la méthode unwrap() ?</a></li>
<li><a href="#a-quoi-sert-la-m%C3%A9thode-and_then">A quoi sert la méthode and_then ?</a></li>
<li><a href="#a-quoi-sert-la-macro-try">A quoi sert la macro try! ?</a></li>
</ul>

<h3>
<a id="a-quoi-sert-la-méthode-unwrap-" class="anchor" href="#a-quoi-sert-la-m%C3%A9thode-unwrap-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert la méthode unwrap ?</h3>

<p>La méthode <code>unwrap()</code> permet de récupérer la donnée contenue par son wrapper et de faire abstraction des « cas d'analyse » avant de la délivrer.</p>

<p>Autrement dit, la méthode <code>unwrap()</code> délivre la donnée enveloppée si l'instance vaut <code>Some</code>() ou <code>Ok</code>(), sinon plante le programme si elle vaut <code>None</code> ou <code>Err</code>().</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">Some</span>(<span class="pl-s">"ça passe!"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>())<span class="pl-k">;</span>
    <span class="pl-k">let</span> bar<span class="pl-k">:</span> <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">None</span><span class="pl-k">;</span>
    <span class="pl-k">let</span> baz<span class="pl-k">:</span> <span class="pl-k">Result</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">,</span> <span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">Ok</span>(<span class="pl-s">"ça passe!"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>())<span class="pl-k">;</span>
    <span class="pl-k">let</span> bing<span class="pl-k">:</span> <span class="pl-k">Result</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">,</span> <span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">Err</span>(<span class="pl-s">"ça casse!"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>())<span class="pl-k">;</span>

    println<span class="pl-k">!</span>(<span class="pl-s">"{} {} {} {}"</span><span class="pl-k">,</span> foo<span class="pl-k">.</span><span class="pl-c1">unwrap</span>()<span class="pl-k">,</span> bar<span class="pl-k">.</span><span class="pl-c1">unwrap</span>()<span class="pl-k">,</span> baz<span class="pl-k">.</span><span class="pl-c1">unwrap</span>()<span class="pl-k">,</span> bing<span class="pl-k">.</span><span class="pl-c1">unwrap</span>())<span class="pl-k">;</span>
}</pre></div>

<p>Voir aussi :</p>

<ul>
<li>
<a href="https://is.gd/GTSlPy" title="Ouvrir un nouvel onglet">Tester l'exemple</a> (Pensez à isoler les appels de la méthode si vous ne souhaitez pas faire planter votre programme.)</li>
<li><a href="#quest-ce-que-l%C3%A9num%C3%A9ration-option">Qu'est-ce que l'énumération Option ?</a></li>
<li><a href="#quest-ce-que-l%C3%A9num%C3%A9ration-result">Qu'est-ce que l'énumération Result ?</a></li>
</ul>

<h3>
<a id="a-quoi-sert-la-méthode-unwrap_or-" class="anchor" href="#a-quoi-sert-la-m%C3%A9thode-unwrap_or-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert la méthode unwrap_or ?</h3>

<p>La méthode <code>unwrap_or()</code> fonctionne exactement comme la méthode originelleunwrap mais permet d'éviter de faire « paniquer » le programme, et donc l'arrêt de l'exécution, en nous permettant de passer une valeur par défaut à renvoyer si le wrapper visé ne contient rien initialement.</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">Some</span>(<span class="pl-s">"ça passe!"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>())<span class="pl-k">;</span>
    <span class="pl-k">let</span> bar<span class="pl-k">:</span> <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">None</span><span class="pl-k">;</span>
    <span class="pl-k">let</span> baz<span class="pl-k">:</span> <span class="pl-k">Result</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">,</span> <span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">Ok</span>(<span class="pl-s">"ça passe!"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>())<span class="pl-k">;</span>
    <span class="pl-k">let</span> bing<span class="pl-k">:</span> <span class="pl-k">Result</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">,</span> <span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">Err</span>(<span class="pl-s">"ça casse!"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>())<span class="pl-k">;</span>

    println<span class="pl-k">!</span>(<span class="pl-s">"{} {} {} {}"</span><span class="pl-k">,</span> foo<span class="pl-k">.</span><span class="pl-c1">unwrap</span>()<span class="pl-k">,</span> bar<span class="pl-k">.</span><span class="pl-c1">unwrap_or</span>(<span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-c1">from</span>(<span class="pl-s">"ça passe, mais de justesse !"</span>))<span class="pl-k">,</span> baz<span class="pl-k">.</span><span class="pl-c1">unwrap</span>()<span class="pl-k">,</span> bing<span class="pl-k">.</span><span class="pl-c1">unwrap_or</span>(<span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-c1">from</span>(<span class="pl-s">"On évite de faire planter le programme."</span>)))<span class="pl-k">;</span>
    <span class="pl-c">/* </span>
<span class="pl-c">        Pensez à isoler les appels de la méthode si vous ne souhaitez pas faire planter votre programme.</span>
<span class="pl-c">    */</span>
}</pre></div>

<p>Voir aussi :</p>

<p><a href="https://is.gd/gwInIj" title="Ouvrir un nouvel onglet">Tester l'exemple</a></p>

<h3>
<a id="a-quoi-sert-la-méthode-unwrap_or_else-" class="anchor" href="#a-quoi-sert-la-m%C3%A9thode-unwrap_or_else-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert la méthode unwrap_or_else ?</h3>

<p>La méthode <code>unwrap_or_else</code> fonctionne exactement comme <code>unwrap_or</code>, mais proposera de passer en paramètre une fonction à la place d'une simple donnée.</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">bang</span>(arg<span class="pl-k">:</span> <span class="pl-k">String</span>) <span class="pl-k">-&gt;</span> <span class="pl-k">String</span> {
    <span class="pl-k">return</span> <span class="pl-s">"Chef, on a eu une erreur: "</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>() <span class="pl-k">+</span> arg<span class="pl-k">.</span><span class="pl-c1">as_str</span>()<span class="pl-k">;</span>
}

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">Some</span>(<span class="pl-s">"ça passe!"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>())<span class="pl-k">;</span>
    <span class="pl-k">let</span> bar<span class="pl-k">:</span> <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">None</span><span class="pl-k">;</span>
    <span class="pl-k">let</span> baz<span class="pl-k">:</span> <span class="pl-k">Result</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">,</span> <span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">Ok</span>(<span class="pl-s">"ça passe!"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>())<span class="pl-k">;</span>
    <span class="pl-k">let</span> bing<span class="pl-k">:</span> <span class="pl-k">Result</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">,</span> <span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">Err</span>(<span class="pl-s">"ça casse!"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>())<span class="pl-k">;</span>

    bar<span class="pl-k">.</span><span class="pl-c1">unwrap_or_else</span>(<span class="pl-k">||</span> { <span class="pl-k">return</span> <span class="pl-s">"On évite la casse !"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()<span class="pl-k">;</span> })<span class="pl-k">;</span>
    println<span class="pl-k">!</span>(<span class="pl-s">"{}"</span><span class="pl-k">,</span> bing<span class="pl-k">.</span><span class="pl-c1">unwrap_or_else</span>(bang))<span class="pl-k">;</span>
}</pre></div>

<p>*<em>Note *</em>: le paramètre que reçoit la fonction <code>bang</code> n'est ni plus ni moins ce que vous avez renseigné dans le contructeur de l'instance <code>Err</code>() <code>bing</code>. Gardez ceci en tête lorsque vous souhaiterez effectuer des opérations sur ce paramètre dans le corps de votre fonction.</p>

<h3>
<a id="a-quoi-sert-la-méthode-map-" class="anchor" href="#a-quoi-sert-la-m%C3%A9thode-map-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert la méthode map ?</h3>

<h3>
<a id="a-quoi-sert-la-méthode-and_then-" class="anchor" href="#a-quoi-sert-la-m%C3%A9thode-and_then-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert la méthode and_then ?</h3>

<p>La méthode and_then() permet d'effectuer des opérations sur la structure qui l'implémente, puis renvoie une nouvelle instance de cette dernière.</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">concat</span>(arg<span class="pl-k">:</span> <span class="pl-k">&amp;</span><span class="pl-k">str</span>) <span class="pl-k">-&gt;</span> <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">&gt;</span> {
    <span class="pl-k">Some</span>(arg<span class="pl-k">.</span><span class="pl-c1">to_string</span>() <span class="pl-k">+</span> <span class="pl-s">"world!"</span>)
}

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo <span class="pl-k">=</span> <span class="pl-k">Some</span>(<span class="pl-s">"Hello "</span>)<span class="pl-k">;</span>
    println<span class="pl-k">!</span>(<span class="pl-s">"{}"</span><span class="pl-k">,</span> foo<span class="pl-k">.</span><span class="pl-c1">and_then</span>(concat)<span class="pl-k">.</span><span class="pl-c1">unwrap</span>())<span class="pl-k">;</span>
}</pre></div>

<p>Actuellement, les structures qui implémentent la méthode <code>and_then()</code> sont :</p>

<ul>
<li>
<code>Option&lt;T&gt;</code>;</li>
<li>
<code>Result&lt;T, E&gt;</code>;</li>
</ul>

<p>Voir aussi :</p>

<ul>
<li><a href="#a-quoi-sert-la-m%C3%A9thode-unwrap">A quoi sert la méthode unwrap() ?</a></li>
<li><a href="#quest-ce-que-l%C3%A9num%C3%A9ration-result">Qu'est-ce que l'énumération Result ?</a></li>
<li><a href="#quest-ce-que-l%C3%A9num%C3%A9ration-option">Qu'est-ce que l'énumération Option ?</a></li>
</ul>

<h3>
<a id="a-quoi-sert-la-macro-try-" class="anchor" href="#a-quoi-sert-la-macro-try-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert la macro try! ?</h3>

<h3>
<a id="comment-utiliser-la-macro-assert-" class="anchor" href="#comment-utiliser-la-macro-assert-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment utiliser la macro assert! ?</h3>

<p>La macro <code>assert!</code> capture deux types « d'expressions » différents :</p>

<p>Les expressions à proprement parler, qui pourraient être illustrées par les exemples suivants :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-c1">2</span> <span class="pl-k">*</span> <span class="pl-c1">2</span><span class="pl-k">,</span> <span class="pl-k">if</span> … <span class="pl-k">else</span> …<span class="pl-k">,</span> <span class="pl-c1">foo</span>() <span class="pl-k">;</span></pre></div>

<p>Les « tokens tree » qui pourraient être illustrés par n'importe quoi d'autres figurant dans la syntaxe du langage. (puisque, dans l'absolu, le compilateur représente tout ce qui est rédigé dans les fichiers sources grâce à une nomenclature bien à lui)</p>

<p>Donc si nous récupérons le code source raccourci de la documentation, cela donne ceci :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">macro_rules!</span> <span class="pl-en">assert</span> {
    ( <span class="pl-k">$</span> cond <span class="pl-k">:</span> expr ) <span class="pl-k">=&gt;</span> { <span class="pl-k">...</span> }<span class="pl-k">;</span>
    (
<span class="pl-k">$</span> cond <span class="pl-k">:</span> expr <span class="pl-k">,</span> <span class="pl-k">$</span> ( <span class="pl-k">$</span> arg <span class="pl-k">:</span> tt ) <span class="pl-k">+</span> ) <span class="pl-k">=&gt;</span> { <span class="pl-k">...</span> }<span class="pl-k">;</span>
}</pre></div>

<p>Si certaines choses vous échappent, n'hésitez pas à vous rendre sur les liens proposés en bas de cette Q/R.</p>

<h4>
<a id="a-quoi-sert-le-second-paramètre-" class="anchor" href="#a-quoi-sert-le-second-param%C3%A8tre-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A quoi sert le second paramètre ?</h4>

<p>Le second peut, par exemple, accueillir un message personnalisé pour la macro panic! facilitant ainsi le débogage.</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">foo</span>(arg<span class="pl-k">:</span> <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">&gt;</span>) {
    <span class="pl-k">let</span> bar<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-c1">from</span>(<span class="pl-s">"Hello world!"</span>)<span class="pl-k">;</span>
    <span class="pl-k">let</span> <span class="pl-k">mut</span> some<span class="pl-k">:</span> <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">None</span><span class="pl-k">;</span>
    assert<span class="pl-k">!</span>(<span class="pl-k">!</span>arg<span class="pl-k">.</span><span class="pl-c1">is_none</span>()<span class="pl-k">,</span> <span class="pl-s">"Arg is None"</span>)<span class="pl-k">;</span>
    assert<span class="pl-k">!</span>(arg<span class="pl-k">.</span><span class="pl-c1">unwrap</span>()<span class="pl-k">.</span><span class="pl-c1">eq</span>(<span class="pl-k">&amp;</span>bar)<span class="pl-k">,</span> <span class="pl-s">"arg n'est pas égal à bar"</span>)<span class="pl-k">;</span>
}

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-c1">foo</span>(<span class="pl-k">Some</span>(<span class="pl-s">"Ok"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()))<span class="pl-k">;</span>
    <span class="pl-c1">foo</span>(<span class="pl-k">None</span>)<span class="pl-k">;</span>
}</pre></div>

<p>Voir aussi :</p>

<ul>
<li>
<a href="https://is.gd/wsqrbp" title="Ouvrir un nouvel onglet">Visionner le résultat de l'exemple</a> (requiert une connexion internet)</li>
<li><a href="#comment-utiliser-une-macro">Comment utiliser une macro ?</a></li>
</ul>

<h3>
<a id="comment-utiliser-la-macro-assert_eq-" class="anchor" href="#comment-utiliser-la-macro-assert_eq-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment utiliser la macro assert_eq! ?</h3>

<p><code>assert_eq!</code> est un dérivé de la macro <code>assert!</code> et permet de tester directement l'égalité de deux objetsLe terme « objet » est ici utilisé pour désigner toutes les entités pouvant être comparées à d'autres. (cela ne concerne donc pas que les instances des structures).</p>

<p>Bien entendu, elle hérite également du message personnalisé pour la macro <code>panic!</code>.</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">foo</span>(arg<span class="pl-k">:</span> <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">&gt;</span>) {
    <span class="pl-k">let</span> bar<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-c1">from</span>(<span class="pl-s">"Hello world!"</span>)<span class="pl-k">;</span>
    <span class="pl-k">let</span> <span class="pl-k">mut</span> some<span class="pl-k">:</span> <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">None</span><span class="pl-k">;</span>
    assert<span class="pl-k">!</span>(<span class="pl-k">!</span>arg<span class="pl-k">.</span><span class="pl-c1">is_none</span>()<span class="pl-k">,</span> <span class="pl-s">"Arg is None"</span>)<span class="pl-k">;</span>
    assert_eq<span class="pl-k">!</span>(arg<span class="pl-k">.</span><span class="pl-c1">unwrap</span>()<span class="pl-k">,</span> bar<span class="pl-k">,</span> <span class="pl-s">"arg n'est pas égal à bar"</span>)<span class="pl-k">;</span>
}

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-c1">foo</span>(<span class="pl-k">Some</span>(<span class="pl-s">"Ok"</span><span class="pl-k">.</span><span class="pl-c1">to_string</span>()))<span class="pl-k">;</span>
    <span class="pl-c1">foo</span>(<span class="pl-k">None</span>)<span class="pl-k">;</span>
}</pre></div>

<p>Voir aussi :</p>

<ul>
<li> <a href="https://is.gd/en8FRZ" title="Ouvrir un nouvel onglet">Visionner le résultat de l'exemple (requiert une connexion internet)</a> </li>
<li> <a href="#comment-utiliser-une-macro">Comment utiliser une macro ?</a> </li>
</ul>

<h3>
<a id="comment-utiliser-la-macro-debug_assert-" class="anchor" href="#comment-utiliser-la-macro-debug_assert-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment utiliser la macro debug_assert! ?</h3>

<h4>
<a id="où-puis-je-lutiliser-" class="anchor" href="#o%C3%B9-puis-je-lutiliser-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Où puis-je l'utiliser ?</h4>

<p><code>debug_assert!</code> ainsi que ses dérivés (<code>debug_assert_eq!</code>) ne sont compilées que lorsque le code source est compilé en mode débug. (mode par défaut de <strong>rustc</strong>)</p>

<p>Vous ne devez pas compter sur ces assertions pour contrôler le flux de votre programme en production, assurez-vous toujours d'avoir une assertion compilée en mode release.</p>

<h4>
<a id="comment-lutiliser-" class="anchor" href="#comment-lutiliser-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment l'utiliser ?</h4>

<p>En dehors du contexte dans lequel ces assertions doivent être déclarées, la manière dont elles sont utilisées ne changent pas.</p>

<p>Voir aussi :</p>

<ul>
<li> <a href="#comment-utiliser-la-macro-assert">Comment utiliser la macro assert! ?</a> </li>
<li> <a href="#comment-utiliser-la-macro-assert_eq">Comment utiliser la macro assert_eq! ?</a> </li>
<li> <a href="#comment-utiliser-une-macro">Comment utiliser une macro ?</a> </li>
</ul>

<h3>
<a id="quest-ce-que-lénumération-result-" class="anchor" href="#quest-ce-que-l%C3%A9num%C3%A9ration-result-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Qu'est-ce que l'énumération Result ?</h3>

<p><code>Result&lt;T, E&gt;</code> est une énumération contenant deux constructeurs :</p>

<ol>
<li>
<code>Ok(T)</code>,</li>
<li>
<code>Err(E)</code>.</li>
</ol>

<p>Elle permet de gérer convenablement les cas où l'entrée <code>T</code> ne correspond pas à nos attentes et ainsi le communiquer au reste du programme pour que l'incident soit rattrapé plus loin si besoin.</p>

<p>Voir aussi : <a href="#comment-utiliser-l%C3%A9num%C3%A9ration-result">Comment utiliser l'énumération <code>Result&lt;T, E&gt;</code> ?</a></p>

<h3>
<a id="comment-utiliser-lénumération-result-" class="anchor" href="#comment-utiliser-l%C3%A9num%C3%A9ration-result-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment utiliser l'énumération Result ?</h3>

<p>L'utilisation de cette énumération requiert quelques notions quant à la gestion des erreurs avec Rust; Ce dernier ne permettant pas l'utilisation des exceptions, cette structure vous permettra de conserver l'entrée si elle correspond à vos attentes, ou le message d'erreur si quelque chose ne s'est pas passé correctement.</p>

<p>Voici un exemple simple de gestion d'erreur :</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">foo</span><span class="pl-k">&lt;</span><span class="pl-k">'a</span><span class="pl-k">,</span> <span class="pl-k">'b</span><span class="pl-k">&gt;</span>(arg<span class="pl-k">:</span> <span class="pl-k">Option</span><span class="pl-k">&lt;&amp;</span><span class="pl-k">'a</span> <span class="pl-k">str</span><span class="pl-k">&gt;</span>) <span class="pl-k">-&gt;</span> <span class="pl-k">Result</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">,</span> <span class="pl-k">&amp;</span><span class="pl-k">'b</span> <span class="pl-k">str</span><span class="pl-k">&gt;</span> {
    <span class="pl-k">if</span> <span class="pl-k">let</span> <span class="pl-k">Some</span>(content) <span class="pl-k">=</span> arg {
        <span class="pl-k">let</span> unwrapping <span class="pl-k">=</span> arg<span class="pl-k">.</span><span class="pl-c1">unwrap</span>()<span class="pl-k">;</span>
        <span class="pl-k">return</span> <span class="pl-k">Ok</span>(unwrapping<span class="pl-k">.</span><span class="pl-c1">to_string</span>())<span class="pl-k">;</span>
    }

    <span class="pl-k">Err</span>(<span class="pl-s">"L'argument ne contient rien."</span>)
}

<span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">match</span> <span class="pl-c1">foo</span>(<span class="pl-k">None</span>) {
        <span class="pl-k">Ok</span>(content) <span class="pl-k">=&gt;</span> println<span class="pl-k">!</span>(<span class="pl-s">"Ok: {}"</span><span class="pl-k">,</span> content)<span class="pl-k">,</span>
        <span class="pl-k">Err</span>(err) <span class="pl-k">=&gt;</span> println<span class="pl-k">!</span>(<span class="pl-s">"Error: {}"</span><span class="pl-k">,</span> err<span class="pl-k">.</span><span class="pl-c1">to_string</span>())<span class="pl-k">,</span>
    }
}</pre></div>

<p>Voir aussi :</p>

<p><a href="#a-quoi-sert-la-macro-try">A quoi sert la macro <code>try!</code> ?</a></p>

<p><a href="#a-quoi-sert-la-macro-panic">A quoi sert la macro <code>panic!</code> ?</a></p>

<p><a href="https://is.gd/kof5ew" title="Ouvrir un nouvel onglet">Le résultat de cet exemple</a></p>

<h3>
<a id="quest-ce-que-lénumération-option-" class="anchor" href="#quest-ce-que-l%C3%A9num%C3%A9ration-option-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Qu'est-ce que l'énumération Option ?</h3>

<p>Option est une énumération contenant deux constructeurs différents : <code>Some(T)</code> et <code>None</code>.</p>

<p>Option est en quelque sorte un wrapper, conteneur permettant de vérifier l'intégrité des données contenues.</p>

<h3>
<a id="comment-utiliser-lénumération-option-" class="anchor" href="#comment-utiliser-l%C3%A9num%C3%A9ration-option-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment utiliser l'énumération Option ?</h3>

<p>Pour utiliser les variantes de l'énumération, il faut savoir à quoi elles correspondent.</p>

<ul>
<li>
<code>Some(T)</code> représente un binding valide;</li>
<li>
<code>None</code> représente un binding invalide.</li>
</ul>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo<span class="pl-k">:</span> <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">Some</span>(<span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-c1">from</span>(<span class="pl-s">"Binding valide"</span>))<span class="pl-k">;</span>
    <span class="pl-k">let</span> bar<span class="pl-k">:</span> <span class="pl-k">Option</span><span class="pl-k">&lt;</span><span class="pl-k">String</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> <span class="pl-k">None</span><span class="pl-k">;</span> <span class="pl-c">//binding invalide, ne contient rien</span>
}</pre></div>

<h2>
<a id="meta-données" class="anchor" href="#meta-donn%C3%A9es" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Meta-données</h2>

<h2>
<a id="io" class="anchor" href="#io" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>I/O</h2>

<h2>
<a id="antisèches-rust" class="anchor" href="#antis%C3%A8ches-rust" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Antisèches Rust</h2>

<h2>
<a id="trucs--astuces" class="anchor" href="#trucs--astuces" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Trucs &amp; astuces</h2>

<h3>
<a id="que-puis-je-trouver-dans-cette-section-" class="anchor" href="#que-puis-je-trouver-dans-cette-section-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Que puis-je trouver dans cette section ?</h3>

<p>Vous pourrez retrouver des « trucs et astuces » pour résoudre un problème plus ou moins commun et complexe.</p>

<p>Ce qui signifie que si vous souhaitez ne serait-ce que conserver des notes quant aux manipulations requises pour se sortir d'un mauvais pas, d'un contexte qui prête à confusion, vos contributions sont les bienvenues dans cette section. :)</p>

<h3>
<a id="comment-récupérer-le-vecteur-dune-instance-de-la-structure-chars-" class="anchor" href="#comment-r%C3%A9cup%C3%A9rer-le-vecteur-dune-instance-de-la-structure-chars-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comment récupérer le vecteur d'une instance de la structure Chars ?</h3>

<p>Il est parfois nécessaire d'éclater une chaîne pour traiter ses caractères au cas par cas ; Jusqu'ici, Rust vous propose une méthode plutôt intuitive nommée <code>chars()</code>.</p>

<p>Après avoir éclatée la chaîne, vous souhaiteriez peut-être itérer plusieurs fois sur celle-ci, sans succès.</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo <span class="pl-k">=</span> <span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-c1">from</span>(<span class="pl-s">"Hello"</span>)<span class="pl-k">;</span>
    <span class="pl-k">let</span> bar <span class="pl-k">=</span> foo<span class="pl-k">.</span><span class="pl-c1">chars</span>()<span class="pl-k">;</span>

    <span class="pl-k">for</span> letter <span class="pl-k">in</span> bar {}
    <span class="pl-k">for</span> letter <span class="pl-k">in</span> bar {}    
}</pre></div>

<p>Erreur :</p>

<pre lang="text"><code>error[E0382]: use of moved value: `bar`
 --&gt; &lt;anon&gt;:7:19
  |
6 |     for letter in bar {}
  |                   --- value moved here
7 |     for letter in bar {}    
  |                   ^^^ value used here after move
  |
</code></pre>

<p>La solution pourrait être la suivante :</p>

<div class="highlight highlight-source-rust"><pre>    <span class="pl-k">let</span> foo <span class="pl-k">=</span> <span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-c1">from</span>(<span class="pl-s">"Hello"</span>)<span class="pl-k">;</span>
    <span class="pl-k">let</span> bar <span class="pl-k">=</span> foo<span class="pl-k">.</span><span class="pl-c1">chars</span>()<span class="pl-k">;</span>

    <span class="pl-k">for</span> letter <span class="pl-k">in</span> <span class="pl-k">&amp;</span>bar {}
    <span class="pl-k">for</span> letter <span class="pl-k">in</span> <span class="pl-k">&amp;</span>bar {}</pre></div>

<pre lang="text"><code>error[E0277]: the trait bound `&amp;std::str::Chars&lt;'_&gt;: std::iter::Iterator` is not satisfied
 --&gt; &lt;anon&gt;:6:5
  |
6 |     for letter in &amp;bar {}
  |     ^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `&amp;std::str::Chars&lt;'_&gt;` is not an iterator; maybe try calling `.iter()` or a similar method
  = note: required by `std::iter::IntoIterator::into_iter`
</code></pre>

<p>Mais récoltez encore une erreur…</p>

<p>Le compilateur vous invite alors à essayer d'appeler la méthode <code>.iter()</code> qui est censée être implémentée par toutes les structures implémentant l'interface <code>Iterator</code>; Ce n'est malheureusement pas le cas pour la structure <code>Chars</code>.</p>

<h4>
<a id="que-faire-alors-" class="anchor" href="#que-faire-alors-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Que faire alors ?</h4>

<p>La méthode remplaçant <code>.iter()</code> est <code>.collect()</code>; Cette dernière vous permet de récupérer un vecteur contenant toutes les entitésEn l'occurrence, ici, les caractères. de l'ancien itérateur.</p>

<p>Vous pouvez désormais accéder à votre ressource par référence et ainsi la parcourir autant de fois que vous le souhaitez.</p>

<div class="highlight highlight-source-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">main</span>() {
    <span class="pl-k">let</span> foo <span class="pl-k">=</span> <span class="pl-k">String</span><span class="pl-k">::</span><span class="pl-c1">from</span>(<span class="pl-s">"Hello"</span>)<span class="pl-k">;</span>
    <span class="pl-k">let</span> bar <span class="pl-k">=</span> foo<span class="pl-k">.</span><span class="pl-c1">chars</span>()<span class="pl-k">;</span>
    <span class="pl-k">let</span> baz<span class="pl-k">:</span> <span class="pl-k">Vec</span><span class="pl-k">&lt;</span><span class="pl-k">char</span><span class="pl-k">&gt;</span> <span class="pl-k">=</span> bar<span class="pl-k">.</span><span class="pl-c1">collect</span>()<span class="pl-k">;</span>
    <span class="pl-k">for</span> letter <span class="pl-k">in</span> <span class="pl-k">&amp;</span>baz {}
    <span class="pl-k">for</span> letter <span class="pl-k">in</span> <span class="pl-k">&amp;</span>baz {}    
}</pre></div>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
